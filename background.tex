\chapter{Background and Motivation}

\section{Descriptive Effect System}

\noindent\textbf{Denotational vs. Descriptive Effects.}  \citet{filinski10} makes a distinction between two strands of work on effects. A \textit{denotational} approach, which includes algebraic effects, defines the semantics of computational effects based on primitives.  A \textit{restrictive} approach (e.g., Java's checked exceptions) takes effects that are already built into the language--such as reading and writing state or exceptions--and provides a way to restrict them. 


\noindent\textbf{Origins of Effect Systems.}  Effect Systems were originally proposed by \citet{lucassen87} to track reads and writes to memory, and then \citet{lucassen88} extended this effect system to support polymorphism.  Effects have since been used for a wide variety of purposes, including exceptions in Java~\cite{kiniry06} and asynchronous event handling~\cite{bracevac18}. \citet{turbak08} previously proposed effects as a mechanism for reasoning about security, which is the main application that we discuss.


\noindent\textbf{Prior Work on Bounded Effect Polymorphism.}  A limited form of bounded effect polymorphism were explored by~\citet{10.5555/645393.651891}, who bound effect parameters by the resources they may act on; however, the bound cannot be another aribrary effect, as in our system.  \citet{DBLP:conf/ecoop/LongLR15} use a form of bounded effect polymorphism internally but do not expose it to users of their system.

\noindent\textbf{Path-Dependent Effects}
JML's data groups~\cite{leino02} have some superficial similarities to Wyvern's effect members.  Data groups are identifiers bound in a type that refer to a collection of fields and other data groups.  They allow a form of abstract reasoning, in that clients can reason about reads and writes to the relevant state without knowing the underlying definitions.  Data groups are designed specifically to capture the modification of state, and it is not obvious how to generalize them to other forms of effects.

The closest prior work on path-dependent effects, by \citet{grennhouse99}, allows programmers to declare regions as members of types; this supports a form of path-dependency in read and write effects on regions.  Our formalism expresses path-dependent effects based on the type theory of DOT~\cite{amin14}, which we find to be cleaner and easier to extend with the unique bounded abstraction features of our system.  Amin et al.'s type members can be left abstract or refined by upper or lower bounds, and were a direct inspiration for our work on bounded abstract effects.

\noindent\textbf{Subeffecting.} 
Some effect systems, such as Koka~\cite{leijen14}, provide a built-in set of effects with fixed sub-effecting relationships between them.
\citet{rytz12} supports more flexibility via an extensible framework for effects.  Users can plug in their own domain of effects, specifying an effect lattice representing sueffecting relationships.  Each plugin is monolithic.  In contrast, our effect members allow new effects to be incrementally added and related to existing effects using declared subeffect bounds.



\section{Algebraic Effects}
\noindent\textbf{Algebraic Effects, Generativity, and Abstraction.}  Algebraic effects and handlers~\cite{plotkin03,plotkin09} are a way of implementing certain kinds of side effects such as exceptions and mutable state in an otherwise purely functional setting.  As described above, algebraic effects fall into the ``denotational'' rather than ``descriptive'' family of effects work; these lines of work are quite divergent, and it is often unclear how to translate technical ideas from one setting to the other.  However, certain papers explore parallels to our work, despite the major contextual differences.


Bra\v{c}evac et al.~\cite{bracevac18} use algebraic effects to support asynchronous, event-based reactive programs. They need to use a different algebraic effect for each join operation that correlates events; thus, they want effects to be generative.  This generativity is at a per-module level, however, whereas our work supports per-object generativity.

\citet{Zhang19} describe a design for algebraic effects that preserves abstraction in the sense of parametric functions: if a function does not statically know about an algebraic effect, that effect tunnels through that function.  This is different from our form of abstraction, in which the definition of an effect is hidden from clients.

\citet{biernacki19} discuss how to abstract algebraic effects using existentials. The setting of algebraic effects makes their work quite different from ours: their abstraction hides the ``handler'' of an effect, which is a dynamic mechanism that actually implements effects such as exceptions or mutable state. In contrast, our work allows a high-level effect to be defined in terms of zero or more lower-level effects, and our abstraction mechanism allows the programmer to hide the lower-level effects that constitute the higher-level effect. Our system, unlike algebraic effect systems, is purely static. We do not attempt to implement effects, but rather give the programmer a system for reasoning about side effects on system resources and program objects. It is not clear that defining a high-level effect that encapsulates multiple low-level events is sensible in the setting of algebraic effects, since this would require merging effect implementations that could be as diverse as mutable state and exception handling. It is also not clear how Biernacki et al.'s abstraction of algebraic effects could apply to the security scenarios we examine in Section~\ref{sec:patterns}, since some of our scenarios rely critically on abstracting lower-level events as higher-level ones.

\section{Wyvern Effect Basics}
\label{sec:wyvern-effects-basics}

\begin{figure}[t]
\begin{lstlisting}
resource type Logger
   effect ReadLog
   effect UpdateLog
   def readLog(): {this.ReadLog} String
   def updateLog(newEntry: String): {this.UpdateLog} Unit

module def logger(f: File): Logger
effect ReadLog = {f.Read}
effect UpdateLog = {f.Append}
def readLog(): {ReadLog} String = f.read()
def updateLog(newEntry: String): {UpdateLog} Unit = f.append(newEntry)
\end{lstlisting}
\caption{A type and a module implementing the logging facility in the text-editor application.}
\label{f-logger}
\end{figure}

Consider the code in Fig.~\ref{f-logger} that shows a type and a module implementing the logging facility of the text-editor application.  In the given implementation of the \li{Logger} type, the \li{logger} module accesses the log file.\footnote{The keyword \li{resource} in the type definition indicates that the implementations of this type may have state and may access system resources; this is orthogonal to effect checking.} All modules of type \li{Logger} must have two methods: the \li{readLog} method that returns the content of the log file and the \li{updateLog} method that appends new entries to the log file. In addition, the \li{Logger} type declares two \textit{abstract} effects, \li{ReadLog} and \li{UpdateLog}, that are produced by the corresponding methods. These effects are abstract because they are not given a definition in the \li{Logger} type, and so it is up to the module implementing the \li{Logger} type to define what they mean. The effect names are user-defined, allowing the choice of meaningful names.

\begin{figure}[t]
\begin{lstlisting}
resource type File
   effect Read
   effect Write
   effect Append
   ...
   def read(): {this.Read} String
   def write(s: String): {this.Write} Unit
   def append(s: String): {this.Append} Unit
   ...
\end{lstlisting}
\caption{The type of the file resource.}
\label{f-file}
\end{figure}

The \li{logger} module implements the \li{Logger} type. To access the file system, an object of type \li{File} (shown in Fig.~\ref{f-file}) is passed into \li{logger} as a parameter. The \li{logger} module's effect declarations are those of the \li{Logger} type, except now they are \textit{concrete}, i.e., they have specific definitions. The \li{ReadLog} effect of the \li{logger} module is defined to be the \li{Read} effect of the \li{File} object, and accordingly, the \li{readLog} method, which produces the \li{ReadLog} effect, calls \li{f}'s \li{read} method. Similarly, the \li{UpdateLog} effect of the \li{logger} module is defined to be \li{f.Append}, and accordingly, the \li{updateLog} method, which produces the \li{UpdateLog} effect, calls \li{f}'s \li{append} method. In general, effects in a module or object definition must always be concrete, whereas effects in a type definition may be either abstract or concrete.


\subsection{Path-dependent Effects}

Effects are members of objects\footnote{Modules are an important special case of objects}, so we refer to them with the form \li{variable.EffectName}, where \li{variable} is a reference to the object defining the effect and \li{EffectName} is the name of the effect. For example, in the definition of the \li{ReadLog} effect of the \li{logger} module, \li{f} is the variable referring to a specific file and \li{Read} is the effect that the \li{read} method of \li{f} produces. This conveniently ties together the resource and the effects produced on it (which represent the operations performed on it), helping a software architect or a security analyst to reason about how resources are used by any particular module and its methods. For example, when analyzing the effects produced by \li{logger}'s \li{readLog} method, a security analyst can quickly deduce that calling that method affects the file resource and, specifically, the file is read, simply by looking at the \li{Logger} type and \li{logger}'s effect definitions but not at the method's code. Furthermore, these properties can be automatically checked with an idiom of use: In addition to directly looking at the effect annotation of the method of the logger module, the security analyst may write client code that specify the effect that the logger module is allowed to have. If the logger module accesses system resources outside of the specified effect set, then the compiler would automatically reject the program.

Because an effect includes a reference to an object instance, our effect system can distinguish reads and writes on different file instances. If the developer does not want this level of precision, it is still possible to declare effects at the module level (i.e., as members of a \li{fileSystem} module object instance), and to share the same \li{Read} and \li{Write} effects (for example) across all files in \li{fileSystem}.

The basic mechanisms of path-dependence are borrowed from Scala and have been shown to scale well in practice. These mechanisms come from the Dependent Object Types (DOT) calculus \cite{amin14}, a type theory of Scala and related languages (including Wyvern). In our system, effects, instead of types are declared as members of objects.

\subsection{Effect Abstraction}
\label{sec:effect-abstraction}

An important and novel feature of our effect system design is the support for \textit{effect abstraction}. Effect abstraction is the ability to define higher-level effects in terms of lower-level effects and potentially to hide that definition from clients of an abstraction. In the logging example above, through the use of abstraction, we ``lifted'' low-level resources such as the file system (i.e., the \li{Read} and \li{Append} effects of the file) into higher-level resources such as a logging facility (i.e., the \li{ReadLog} and \li{UpdateLog} effect of the logger) and enabled application code to reason in terms of effects on those higher-level resources when appropriate.

Effect abstraction has several concrete benefits. First, it can be used to distinguish different uses of a low-level effect. For example, \li{system.FFI} describes any access to system resources via calls through the foreign function interface (FFI), but modules that define file and network I/O can represent these calls as different effects, which enables higher-level modules to reason about file and network access separately. Second, multiple low-level effects can be aggregated into a single high-level effect to reduce effect specification overhead. For instance, the \li{db.Query} effect might include both \li{file.Read} and \li{network.Access} effects. Third, by keeping an effect abstract, we can hide its implementation from clients, which facilitates software evolution: code defining a high-level effect in terms of lower-level ones can be rewritten (or replaced) to use a different set of lower-level effects without affecting clients (more on this in Section~\ref{sec-information-hiding}).


\subsection{Effect Aggregation}

Wyvern's effect-system design allows reducing the effect-annotation overhead by aggregating several effects into one. For example, if, to update the log file, the \li{logger} module needed to first read the file and then write it back, the \li{UpdateLog} effect would consist of two effects: a file read and a file write. In other effect systems, this change may make effects more verbose since all the methods that call the \li{updateLog} method would need to be annotated with the two effects. However, effect aggregation allows us to define the \li{UpdateLog} effect to be the two effects and then use \li{UpdateLog} to annotate the \li{updateLog} method and all methods that call it:

\begin{minipage}{\linewidth}
\begin{lstlisting}[xleftmargin=-5pt, numbers=none]
module def logger(f: File): Logger
effect UpdateLog = {f.Read, f.Write}
def updateLog(newEntry: String): {this.UpdateLog} Unit
...
\end{lstlisting}
\end{minipage}
This way we need to use only one effect, \li{UpdateLog}, instead of two, in method effect annotations, thus reducing the effect-annotation overhead. Because more code may add more effects, larger software systems might experience a snowballing of effects, when method annotations have numerous effects in them.


\subsection{Controlling FFI Effects}
Wyvern programs access system resources via calls to other programming languages, such as Java and Python, i.e., through a foreign function interface (FFI). To monitor and control the effects caused by FFI calls, we enforce that all functions from other programming languages, when called within Wyvern, are annotated with the \li{system.FFI} effect. 

As was mentioned in Section~\ref{sec:effect-abstraction}, the \li{system.FFI} effect is an effect that describes function calls though an FFI. Since every function call though FFI has this effect, the access to system resources via FFI is guaranteed to be monitored. \li{system.FFI} is the lowest-level effect in the effect system which can be used to build other higher-level effects. The programmer can lift \li{system.FFI} to higher-level effects and reason about those higher-level effects instead.


For example, Wyvern’s import mechanism works by loading an object in a static field of a Java class, and the following code imports a field of a Java class that helps to implement file IO:\\
\begin{minipage}{\linewidth}
\begin{lstlisting}[xleftmargin=-5pt, numbers=none]
  import java:wyvern.stdlib.support.FileIO.file
\end{lstlisting}
\end{minipage}

The file object is itself of type FileIO. And FileIO has this method, among others: \\
\begin{minipage}{\linewidth}
\begin{lstlisting}[xleftmargin=3pt, numbers=none]
public void writeStringIntoFile(String content, String filename) throws IOException { ... }
\end{lstlisting}
\end{minipage}

In Wyvern, there is a type wyvern.stdlib.support.FileIO as well as an object file (of that type) that gets added to the scope as a result of the import above. The type has the following member, corresponding to the method above: \\
\begin{minipage}{\linewidth}
\begin{lstlisting}[xleftmargin=-5pt, numbers=none]
  def writeStringIntoFile(content:String, filename:String): { system.FFI } Unit 
\end{lstlisting}
\end{minipage}

Here, the system.FFI effect was added to the signature because this is a function that was imported via the FFI. The Wyvern file library that uses the \li{writeStringIntoFile} function abstracts this \li{system.FFI} effect into a library-specific \li{FileIO.Write} effect.



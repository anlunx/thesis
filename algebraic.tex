% !TEX root = thesis.tex

\chapter{Abstract Algebraic Effects via Embeddings}
\label{chapter-algebraic}

\section{Background and Motivation}
\label{sec-motivation}

Algebraic effects (introduced by \citet{plotkin02}) and handlers (introduced by \citet{plotkin09}) are an approach to computational effects based on a premise that impure behavior arises from a set of operations, and are recently gaining popularity due to their ability to model various form of computational effects such as exceptions, mutable states, async-await, etc.

Modularity is a key concept that separates abstract algebraic effects from the traditional way of using monad to model effects in purely functional programming \cite{schrijvers19}. However, similar to the restrictive strand of work on effects, few works on algebraic effects have investigated the algebraic effect system on a larger scale, where abstraction between program components is important. 

Abstract algebraic effects are first introduced in \citet{biernacki19}. Similar to abstract types, abstract algebraic effects allow program components to define abstract effect signatures that are opaque to other components in the system. The difference between concrete and abstract effect signatures lies in the ability of program components to handle them. If an effect signature is concrete to a program component, then the operations are accessible to the component, and a handler can handle the effect by handling the operations in the signature. On the other hand, if an effect signature is abstract to one program component, then the component should not observe the operations defined in the effect signature, and is therefore unable to handle the effect. As abstraction is an important issue for module systems because it provides a separation of implementation details of functions from the interface, the abstraction of algebraic effects provides a similar benefit for modularity because it helps separate the component operations from the effect signature, ensuring that the client can only use the handler provided by the library to handle the effect.

The following code is a motivating example similar to the example in \cite{biernacki19} that illustrates the challenges of implementing abstract algebraic effects. \li{Nondet} is a globally defined effect signature. Then we define a module \li{m} with type \li{M} with an abstract effect \li{E}, a method \li{mflip}, and a handler method \li{handle}. The effect \li{E} is defined by \li{Nondet}, but is opaque to the outside world of the module, because \li{E} is defined as an abstract effect in the type \li{M}. The method \li{mflip} simply calls the \li{flip} operation, and the \li{handle} method handles the \li{flip} operation by returning \li{true}. 

\begin{lstlisting}[language=wyvern, float]  
effect Nondet {
    flip(): Bool  
}

type M
  effect E 
  def mflip() : {this.E} Bool
  def handler(Unit -> {this.E} Bool) : {} Bool
  
module m: M
  effect E = {Nondet}
  def mflip() : {this.E} Unit
    flip()
  def handle(c: Unit -> {this.E} Bool) : {} Bool = 
    handle c() with
    | flip() -> resume true

m.handle(
  () => handle m.mflip() with
        | flip() ->  resume false
        | return x -> x
)
\end{lstlisting}

The last segment of the  example shows a client code of module \li{m} that calls the method \li{m.handle} and pass in an expression that encapsulates the call to \li{m.mflip} with another handler that handles the \li{flip} operation. Since the effect of the method \li{m.mflip} is abstract, the inner handler should not handle the operation inside \li{m.mflip}. Instead, the operation should be handled by the outer handler method \li{m.handle}.  

As we can see, the abstraction of effect signatures differs from type abstractions, since the erasure of type information would make the abstraction unsound. So we need a language that keeps track of the information on effect abstraction during the evaluation of the program. In this work, we incorporate the method of syntactic type abstraction introduced by \citet{grossman00}, who use the notion of principals to track the flow of values with abstract types during the evaluation of a program. 

\section{A Simple Example of the Agent-based Language}
Consider the simple case where we only have two agents, namely the client \li{c}, and the host \li{h}. And the host \li{h} defines an abstract effect \li{E}, exports a method that causes the effect, and a method that handles the effect.
\begin{lstlisting}[mathescape=true]
module h = 
  effect E = ...
  val m : 1 -> {E} 1 = ..
  ...
\end{lstlisting}

Now consider client code wants to handle the \li{m} function from h\\
\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape=true]
handle 
  [m ()]$_h^E$
with
  op (x) -> ...
  return x -> ...
\end{lstlisting}
\end{minipage}

Since function \li{m} is called in the client code, we use a language construct called embedding to encapsulate the function call. The subscript \li{h} of the embedding indicates that the code inside the embedding is the host code, and the superscript \li{E} indicates that the effect of the code is \li{E}, which is abstract to the client. So the embedding ensures that the client would not be able to handle the operation inside the function \li{m}, therefore keeping the effect abstraction safe. 

Besides making the client unable to handle an abstract effect, we need to make sure that a host code can ``rediscover" the effect exported by itself. The scenario would be exhibited by the following host code. The client code we showed earlier is now embedded into a host handler that handles the effect E. Because the outer-most handler is now in host code, it would be able to handle the effect operation inside the function \li{m}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape=true]
handle 
  [handle 
    [m ()]$_h^E$
  with
    op (x) -> ...
    return x -> ...]$_c^E$
with
  op (x) -> ...
  return x -> ...
\end{lstlisting}
\end{minipage}




\section{Core Calculus}
\label{sec-core}
\subsection{Syntax}
\begin{figure}
\begin{align*}
&\text{(agents)} &i, j &::= \{1 \dots n\}\\
&\text{(lists)} & l &::= i \mid il\\
&\text{(value types)} &\tau &::= 1 \mid \tau \rightarrow \sigma\\
&\text{(computation\ types)} &\sigma &::= \{\varepsilon\}\tau\\
&\text{(effect types)} &\varepsilon &::= \cdot \mid f, \varepsilon \mid op, \varepsilon\\
&\text{(i-values)} &{v_i} &::= ()_i \mid \lambda x_i:\tau.\ c_i\\
&\text{(i-expressions)} &e_i &::= x_i \mid v_i \mid [e_j]^\tau_j \\
& \text{(i-computations)} &c_i &::= \texttt{return}\ e_i \mid op(e_i, y.c_i) \mid \texttt{do}\ x \leftarrow c_i\ \texttt{in}\ c_i' \mid e_i\ e_i'\\
 &\ &\ &\  \mid \texttt{with}\ h_i\ \texttt{handle}\ c_i \mid\ [c_j]^\sigma_j \mid [op]^\varepsilon_l (e_i, y_i.c_i)\\
&\text{(i-handlers)} &h_i &::= \texttt{handler}\ \{\texttt{return}\ x_i \mapsto c^r_i, op^1(x_i^1, k^1) \mapsto c_i^1, \dots ,  op^n(x_i^n, k^n) \mapsto c_i^n\}  
\end{align*}
\caption{Syntax for multi-agent calculus}
\label{fig-core}
\end{figure}

This section describes a variant of the simply typed lambda calculus that maintains a syntactic distinction between agents during evaluation. Figure \ref{fig-core} gives the syntax of our calculus. As our previous discussion, it is crucial to keep track of the effect abstraction information during the evaluation of the program. It is therefore natural to divide the code into agents and allow each agent to export abstract effect signatures. We assume that there are $n$ agents, and variables $i, j, k$ range over the set of agents. 

Every term in this language is assigned to an agent. And terms are split into inert expressions and potentially effectful computations, following an approach called \emph{fine-grain call-by-value}, introduced by \citet{levy03}. We use the notation \emph{i-expression} and \emph{i-computation} to denote expressions and computations in the agent i. We use subscripts to indicate a term is assigned to an agent, however, we will omit the subscript if the agent the term belongs to is not important or obvious in the context.

An \emph{i-value} is an \emph{i-expression} that cannot be further reduced. There are two forms of \emph{i-value}: the unit $()$, and the lambda abstraction $\lambda x_i: \tau.\ c_i$. \emph{i-expressions} include variable $x_i$, value $v_i$, and embedded expressions $[e_j]^\tau_j$. \emph{i-computations} are the terms that can potentially cause effects, and consists of return statement $\m{return} e_i$, operation call $op(e_i; y_i.c_i)$, sequencing $\m{do} x_i \leftarrow c_i \m{in} c_i'$, application $e_i\ e_i'$, handling $\m{with} h_i \m{handle} c_i$, embedded computation $[c_j]^\sigma_j$, and embedded operation call $[op]^\varepsilon_l(e_i; y_i.c_i)$. There are a few things worth mentioning: 
\begin{enumerate}
\item[] \textbf{Sequencing}: In $\m{do} x \leftarrow c \m{in} c'$, we first evaluate $c$,  bind the return value of $c'$ to x and then evluate $c_2$
\item[] \textbf{Operation Calls}: The call $op(e; y.c)$ passes the parameter $e$ to the operation $op$,  binds the return value of the operation call to $y$, and continue by evaluating the computation $c$. Note that the encompassing handler could potentially change the behavior of the operation.  Explicit continuations greatly simplifies the operational semantics of the language, because continuations make the order of the execution of operations explicit. 
\item[] \textbf{Embeddings}: the term $[e_j]^\tau_j$ is an i-expression, where $e_j$ is an embedded j-expression. The type $\tau$  is exported by the agent $j$ as the type of the embedded expression. Similarly, $[c_j]^\sigma_j$ is an embedded j-computation with exported type $\sigma$.
\item[] \textbf{Embedded Operations}: The embedded operation $[op]^\varepsilon_l(e; y.c)$ is an operation call that is annotated with effect $\varepsilon$. $l$ is a list of agents that have contributed to the formation of the annotation.  The embedded operations should not appear in the source code, as they are an intermediate form of computation that keeps track of the effect annotation of operations. More details of this construct are given in section \ref{sec-op} on Operational Semantics.
\end{enumerate} 

Similar to terms, types are also divided into expression types and computation types. There are two forms of expression types $\tau$: the unit type $1$, and the arrow type $\tau \rightarrow \sigma$. As for the computation type $\sigma$, there is only one form: $\{\varepsilon\}\tau$, where $\varepsilon$ is a set of effects that the computation might induce, and $\tau$ is the type of the return value of the computation. 

The effect type $\varepsilon$ represents an unordered set of effects that can be empty $\cdot$. A effect type can be extended by either an effect label $f$, or an operation $op$.

The i-handler $h_i$ must contain a return clause $\m{return} x \mapsto c$, which handles the case when the handled computation directly returns a value. The returned value is bound to the variable $x$, and the entire handling computation evaluates to the computation $c$. A handler may also contain clauses that handle operations. For example, the clause $op(x, k) \mapsto c$ handles the operation $op$. More details can be found in the dynamic semantics section.

\subsection{Agent-Specific Type Information}
We use agents to model a module system where each module can have private information about effect abstraction. Each agent in our language has limited knowledge of effect abstraction. For example, an agent i might knows that effect \li{Nondet = flip(): Bool}, and an agent $j$ does not have this information. As a result, agent i would be able to handle a computation with effect \li{Nondet}, while the agent j would not be able to handle the effect, because from agent j's point of view, the effect \li{Nondet} is an abstract label without an operation. Furthermore, we need to ensure the consistency of the information on effect abstraction, that is, agent j should not think that the effect \li{Nondet = read(): String}, which would contradict with the knowledge of agent i. 

The model of effect abstraction information is similar to the model of type information in \cite{grossman00}. To capture effect abstraction information, each agent $i$ has a partial function $\delta_i$ that maps an effect label to an effect type. There are two requirements for these maps: (1) For each effect label $f$, the if there are two agents that knows the implementation of the effect $f$, then their knowledge about the implementation must be the same. (2) For each effect label $f$, there is a unique and most concrete interpretation of $f$. We would not allow the effect label $f$ itself to appear in the implementation of $f$. Examples like $\delta_i(f) = \{f\}$ and $\delta_i(f) = \{f, op\}$ would be rejected.

\begin{definition}
A set $\{\delta_1, \dots, \delta_n\}$ of maps from effect labels to effects is \underline{compatible} if
\begin{enumerate}
\item For all $i, j \in 1 \dots n$ if $f \in Dom(\delta_i) \cap Dom(\delta_j)$, then $\delta_i(f) = \delta_i(j)$.
\item Effect labels can be totally ordered such that for every agent $i$ and effect label $f$, all effect labels in $\delta_i(f)$ precede $f$.
\end{enumerate}
\end{definition}

Then we define the a total function $\Delta_i$ that refines an effect type:
\begin{definition}
$\Delta_i$ is a function that maps an effect type to another effect type, using the effect abstraction knowledge of the agent i.
\begin{align*}
\Delta_i(\cdot) &= \cdot \\
\Delta_i(op, \varepsilon) &= op, \Delta_i(\varepsilon) \\
\Delta_i(f, \varepsilon) &= 
    \begin{cases}
      f, \Delta_i(\varepsilon) & \text{if}\ f \not\in Dom(\delta_i)  \ \\
      \varepsilon', \Delta_i(\varepsilon) & \text{if}\ \delta_i(f) = \varepsilon'
    \end{cases}
\end{align*}
\end{definition}

The definition of compatibility ensures that there is a fixpoint for repeatedly refining an effect label $\varepsilon$ using the function $\Delta_i$. We call such fixpoint $\overline{\Delta_i}(\varepsilon)$. 


\begin{definition}
$\overline{\Delta_i}(\varepsilon') = \varepsilon$ if there is some $n \geq 0$
\[
    \underbrace{\Delta_i(\dots (\Delta_i(\varepsilon') \dots )}_\text{n applications}   = 
    \underbrace{\Delta_i(\dots (\Delta_i(\varepsilon') \dots )}_\text{n+1 applications}   = \varepsilon
 \]
 \end{definition}
 
 To see how we apply $\Delta$ to reach a fix point, consider two effect labels $f$ and $g$ and an agent $i$. Agent i knows that the effect $f$ is implemented by two operations $op_1$ and $op_2$. Then consider applying $\Delta_i$ to the effect type $f, g$. We get $\Delta_i(f, g) = op_1, op_2, g$. Since $op_1$, $op_2$, and label $g$ is the most concrete form of effects, $\Delta_i$ cannot further refine the resulting type, so we have reached the fix point. So we have $\overline{\Delta_i}(f, g) = op_1, op_2, g$. As we can see, by repeatedly applying $\Delta_i$ and getting to a fixpoint, we effectively collect all operations and abstract effect labels in the agent i's perspective.



 We assume that the type information for operations is public to all agents. The type  for an operation $op$ is contained by a separate map $\Sigma$, which maps an operation $op$ to an arrow type $\tau_A \rightarrow \tau_B$. Note that this is different from the function type in our calculus, which has the form $\tau \rightarrow \sigma$.




\section{Operational Semantics}
\label{sec-op}
\begin{figure}[t]
\footnotesize{


$\fbox{$e \longrightarrow e'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Congruence)}]
  {[e_j]^\tau_j \longrightarrow [e_j']^\tau_j}
  {e_j \mapsto e_j'} \quad 

\infer[\textsc{(E-Unit)}]
  {[()_j]^{1}_j \longrightarrow ()_i}
  {} \\[3ex]
  
\infer[\textsc{(E-Lambda)}]
  {[\lambda x_j : \tau'.\ c_j]^{\tau \rightarrow \sigma}_{j} \longrightarrow \lambda x_i : \tau.\ [\{[x_i]^{\tau'}_{i}/x_j\}c_j]^\sigma_{j}}
  {} 
\end{array}
\]
}
\caption{Operational Semantics for Expressions}
\label{fig-op1}

\end{figure}

\begin{figure}[p]
\footnotesize{

$\fbox{$c \longrightarrow c'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Ret)}]
  {\texttt{return}\ e_i \longrightarrow \texttt{return}\ e_i'}
  {e_i \mapsto e_i'} \quad
  
\infer[\textsc{(E-Op)}]
  {op(e_i,y_i.c_i) \longrightarrow op(e_i', y_i, c_i)}
  {e_i \mapsto e_i'} \\[3ex]
 
 \infer[\textsc{(E-Embed1)}]
{[c_j]^\sigma_l \longrightarrow [c_j']^\sigma_l}
{c_j \longrightarrow c_j'} \quad 



\infer[\textsc{(E-Embed2)}]
{[\m{return} v_j]^{\{\varepsilon\}\tau}_l \longrightarrow \m{return} [v_j]^\tau_l}
{} \\[3ex]

\infer[\textsc{(E-Embed3)}]
{[op_j(v_j; y_j.c_j)]^{\{\varepsilon\}\tau}_j \longrightarrow [op_j]^\varepsilon_j([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_j)}
{ \Sigma(op) = \tau_A \rightarrow \tau_B} \\[3ex]

\infer[\textsc{(E-Embed4)}]
{[[op_k]^{\varepsilon'}_{l}(v_j; y_j.c_j)]^{\{\varepsilon\}\tau}_j \longrightarrow [op_k]^\varepsilon_{lj}([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_j)}
{ \Sigma(op) = \tau_A \rightarrow \tau_B& \Delta_j(\varepsilon') = \varepsilon' & op \not \in \varepsilon'} \\[3ex]




 
\infer[\textsc{(E-EmbedOp1)}]
{[op]^\varepsilon_l(e_i; y_i.c_i) \longrightarrow [op]^{\varepsilon}_l(e_i'; y_i.c_i) }
{e_i \longrightarrow e_i'} \quad
 
\infer[\textsc{(E-EmbedOp2)}]
{[op]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow [op]^{\varepsilon'}_l(v_i; y_i.c_i) }
{\overline{\Delta_i}(\varepsilon) = \varepsilon'} \\[3ex]

\infer[\textsc{(E-EmbedOp3)}]
{[op]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow op(v_i; y_i.c_i) }
{\Delta_i(\varepsilon) = \varepsilon & op \in \varepsilon} \quad

\infer[\textsc{(E-EmbedOp4)}]
{[op]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow [op]^{\varepsilon \setminus op'}(v_i; y_i.c_i) }
{\Delta_i(\varepsilon) = \varepsilon & op \not\in \varepsilon & op' \in \varepsilon} \\[3ex]


\infer[\textsc{(E-App1)}]
  {e_i\ e_i' \longrightarrow e_i''\ e_i'}
  {e_i \longrightarrow e_i''}  \quad
  
\infer[\textsc{(E-App2)}]
  {v_i \ e_i \longrightarrow v_i\ e_i'}
  {e_i\longrightarrow e_i'}  \quad
  
\infer[\textsc{(E-App3)}]
  {(\lambda x_i:\tau.\ c_i) \ v_i \longrightarrow \{v_i/x_i\}c_i}
  {} \\[3ex]
  
  
\infer[\textsc{(E-Seq1)}]
  {\texttt{do}\ x \leftarrow c_i\ \texttt{in}\ c_i' \longrightarrow \texttt{do}\ x \leftarrow c_i''\ \texttt{in} c_i'}
  {c_i \longrightarrow c_i''}  \quad
  
\infer[\textsc{(E-Seq2)}]
  {\texttt{do}\ x \leftarrow \texttt{return}\ v_i \ \texttt{in}\ c_i' \longrightarrow \{v_i/x\} c_i'}
  {} \\[3ex]
  
\infer[\textsc{(E-Seq3)}]
  {\texttt{do}\ x \leftarrow op_i(v_i; y_i.c_i) \texttt{in}\ c_i' \longrightarrow op_i(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i')}
  {} \\[3ex]
  
\infer[\textsc{(E-Seq4)}]
  {\texttt{do}\ x \leftarrow [op_j]^\varepsilon_l(v_i; y_i.c_i) \texttt{in}\ c_i' \longrightarrow [op_j]^\varepsilon_l(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i')}
  {\Delta_i(\varepsilon) = \varepsilon & op \not \in \varepsilon} \\[3ex]
  

  
 \infer[\textsc{(E-Handle1)}]
  {\m{with} h_i \m{handle} c_i \longrightarrow \m{with} h_i \m{handle} c_i' }
  {c_i \longrightarrow c_i'} \\[3ex]
  
\infer[\textsc{(E-Handle2)}]
  {\m{with} h_i \m{handle} \m{return} v_i \longrightarrow \{v_i/x_i\}c_i' }
  {\m{return} x_i \mapsto	c_i' \in h_i} \\[3ex]
  
\infer[\textsc{(E-Handle3)}]
  {\m{with} h_i \m{handle} op(v_; y_i.c_i) \longrightarrow \{v_i/x_i\} \{(\lambda y_i: \tau_B.
   \m{with} h_i\m{handle} c_i) / k\}c_i' }
  {op(x_i; k) \mapsto c_i' \in h_i & \Sigma(op) = \tau_A \rightarrow \tau_B} \\[3ex]
 
 
\infer[\textsc{(E-Handle4)}]
  {\m{with} h_i \m{handle} op(v_i, y_i.c_i) \longrightarrow op(v_i; y_i. \m{with} h_i \m{handle} c_i))}
  {op(x_i; k) \mapsto c_i' \not\in h_i } \\[3ex]
  
\infer[\textsc{(E-Handle5)}]
  {\m{with} h_i \m{handle} [op]^\varepsilon_l(v_i, y_i.c_i) \longrightarrow [op]^\varepsilon_l(v_i; y_i. \m{with} h_i \m{handle} c_i))}
  {\Delta_i(\varepsilon) = \varepsilon & op \not \in \varepsilon} \\[3ex]
  


\end{array}
\]

}
\caption{Operational Semantics for Computations}
\label{fig-op2}

\end{figure}

The reduction rules for terms are dependent on the agent of the terms. Figure \ref{fig-op1} shows that operational semantics for expressions of agent i. (E-Congruence) shows that a j-expression embedded agent-i should be evaluated using the reduction rules for agent j first. The (E-Unit) and (E-Lambda) rules show that we can lift an embedded j-value to agent i, so the value becomes an i-value. The (E-Unit) rule simply lifts the unit value out of the embedding. The (E-Lambda) rule is more interesting: The value embedded is a lambda expression of agent j. We lift the argument out of the embedding. However, the type annotating the argument is changed from $\tau'$ to the exported argument type $\tau$, because the reduced expression should have the exported type $\tau \rightarrow \sigma$. The body of the reduced expression is an embedded j-computation, so the variable $x_i$ should be encapsulated by an embedding, because any i-term should be embedded in a j-term. We annotate $x_i$ with type $\tau'$ because the original lambda function expects a value of type $\tau'$. 

Figure \ref{fig-op2} shows the reduction rules for i-computations. (E-Ret) is the congruence rule that evaluates the expression in a return statement. (E-Op) evaluates the input argument for the operation call. Note that there is no non-congruence reduction rule for operation calls because the semantics for operations are defined by the handler encapsulating it. 

(E-Embed1) is the congruence rule for embedded computations. (E-Embed2) lifts the return statement out of the embedding. We can safely remove the effect annotation $\varepsilon$ because the statement that returns a value $v_j$ cannot cause any effect. 

(E-Embed3) lifts an operation call out of the embedding. This rule introduces embedded operation as a new language construct. We annotate the embedded operation with the effect annotation of the whole computation. Since the argument value for $op$ is a j-value, we need to embed it as an i-value, and annotate it with type $\tau_A$. The continuation $c_j$ is still embedded, and we substitute the embedded variable $y_i$ for $y_j$. $y_i$ should be embedded because  i-values should be embedded in a j-value.

The (E-Embed4) rule is very similar to (E-Embed3) with one difference being that $op$ is already embedded. In this case, we override the annotation on $op$ with the annotation for the whole computation and update the agent list in the subscript of the operation. We add $j$ to the agent list because the agent j has contributed to the effect annotation of the operation.


(E-EmbedOp1) evaluates the argument of an embedded operation. (E-EmbedOp2) refines the effect annotation of an operation by looking up the effect $\varepsilon$ from the type information of the agent i, $\Delta_i$. (E-EmbedOp3) lifts the operation out of an embedding when the annotation contains the operation, because the agent i has enough information about effect abstraction to handle the operation. Note that in the premise, we require that the effect annotation cannot be further refined, in order to ensure determinism of evaluation. (E-EmbedOp4) removes an operation that is not $op$ out of the effect annotation. This step does not affect the correctness of the type information, and is helpful in our proof of type soundness.

(E-App1), (E-App2) and (E-App3) are standard call-by-value semantics for applications. (E-Seq1) evaluates the first computation in a sequence of computations. (E-Seq2) binds the return value of the first computation to a variable in the second computation. (E-Seq3) witnesses an operation call as the first computation in a sequence. Since there is no way to further evaluate an operation right away, we propagate the operation call outwards and defer further evaluation to the continuation of the call. (E-Seq4) is similar to (E-Seq3), and requires that the effect annotation on the embedding to be the most concrete annotation. 

(E-Handle1) simply evaluates the computation encapsulated by the handler. In (E-Handle2), the computation returns a value, so we substitute the value into the computation of the clause that handles the return statement in the handler. (E-Handle3) shows that case when the handler $h_i$ has a matching clause for the operation $op$. We substitute the argument $v_i$ for $x_i$, and substitute the continuation of the operation for $k$. The continuation function receives an argument of type $\tau_B$, which is the result type of the operation $op$, and computes the continuation of the operation $c_i$, but encapsulates the computation with the handler $h_i$. The (E-Handle4) shows the case when the operation is not handled by the handler, so we propagate the operation outwards to wait for another handler to handle it. The (E-Handler5) ensures that abstracted effects are not handled: If the current agent cannot refine the effect annotation, then the operation is abstract and cannot be handled, and is therefore propagated outward. 



\section{Static Semantics}
\subsection{Typing Rules}

\begin{figure}[t]
\footnotesize{
\noindent$\fbox{$\Gamma \vdash e_i : \tau$}$
\[
\begin{array}{c}

\infer[\textsc{(T-unit)}]
  {\Gamma \vdash ()_i : 1}
  {} \quad 

\infer[\textsc{(T-var)}]
  {\Gamma \vdash x_i : \Gamma(x_i)}
  {} \quad 

\infer[\textsc{(T-lam)}]
  {\Gamma \vdash (\lambda x_i: \tau.\ c_i) : \tau \rightarrow \sigma}
  {\Gamma, x_i:\tau \vdash c_i : \sigma} \\[3ex]
  
\infer[\textsc{(T-EmbedExp)}]
  {\Gamma \vdash [e_j]^\tau_j : \tau}
  {\Gamma \vdash e_j : \tau' & \Gamma \vdash \tau' \leq_{ji} \tau} \quad  
\end{array} \\[3ex]
\]


\noindent$\fbox{$\Gamma \vdash c_i : \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(T-ret)}]
  {\Gamma\vdash \m{return} e_i : \{\varepsilon\}\tau }
  {\Gamma\vdash e_i : \tau & \Delta_i(\varepsilon) = \varepsilon} \quad 
  
\infer[\textsc{(T-op)}]
  {\Gamma\vdash op(e_i; y_i.c_i) : \{\varepsilon\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon\}\tau & op \in \Delta_i(\varepsilon)} \\[3ex]


\infer[\textsc{(T-seq)}]
  {\Gamma\vdash \m{do} x_i \leftarrow c_i \m{in} c_i' : \{\varepsilon\}\tau' }
  {\Gamma \vdash c_i : \{\varepsilon\}\tau & \Gamma, x_i:\tau \vdash c_i': \{\varepsilon\}\tau'} \quad 
  
  
\infer[\textsc{(T-app)}]
  {\Gamma\vdash e_1\ e_2\ : \sigma }
  {\Gamma \vdash e_1 : \tau \rightarrow \sigma & \Gamma \vdash e_2 : \tau} \\[3ex]
  
\infer[\textsc{(T-handle)}]
  {\Gamma\vdash \m{with} h_i \m{handle} c_i: \{\varepsilon'\} \tau_B}
  {\begin{gathered}
  h_i = \{\m{return} x \mapsto c^r, op^1(x;k) \mapsto c^1, \dots, op^n(x;k) \mapsto c^n \}\\
  \Gamma, x: \tau_A \vdash c^r : \{\varepsilon'\}\tau_B \quad
  \left\{ \Sigma(op^i) = \tau_i \rightarrow \tau_i'  \quad \Gamma, x:\tau_i, k:\tau_i' \rightarrow \{\varepsilon'\}\tau_B \vdash c^i: \{\varepsilon'\}\tau_B    \right\}_{1 \leq i \leq n} \\
  \Gamma \vdash c_i : \{\varepsilon\}\tau_A \quad \varepsilon \setminus \{op^i\}_{1 \leq i \leq n} \subseteq \varepsilon'
  \end{gathered}} \\[3ex]
  
\infer[\textsc{(T-Embed)}]
  {\Gamma\vdash [c_j]^\sigma_l : \sigma }
  {\Gamma \vdash c_j : \sigma' & \Gamma \vdash \sigma' \leq_{li} \sigma  } \\[3ex]
  
\infer[\textsc{(T-EmbedOp)}]
  {\Gamma\vdash [op]^\varepsilon_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma,y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau & \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon') & \Gamma \vdash op \leq_{li} \varepsilon} \\[3ex]
  
\end{array} \\[3ex]
\]
}


\caption{Static Semantics}
\label{fig-static}
\end{figure}

Figure \ref{fig-static} shows the static semantics of the core-calculus. Static semantics includes typing rules for both expressions and computations. Note that the typing rules depend on the agent each expression or computation belongs to. We assume that the following rules assign types to terms of agent i.

The rule (T-Unit) assigns the unit type $1$ to a unit value. (T-Var) looks up a type of a variable from the context. (T-Lam) is the standard rule for typing a lambda function. Note that the body of a lambda is computation, so we need to use the typing judgment for computation in the premise of this rule. (T-EmbedExp) assigns type to expression embeddings: The embedding has type $\tau$ if the embedded expression $e_j$ is assigned to the type $\tau'$, and $\tau$ is related to $\tau'$ by the list of agents $li$. We will elaborate on type relations later. 

(T-Ret) assigns a type to a return statement: As expected, the expression part of the computation type matches the type of the returned expression. However we can annotate the return statement with an arbitrary effect set, because our type system does not describe the precise effect in computations, but gives the upper bound of effect in computations.  

(T-Op) shows the typing rule for operation calls. Again, since we allow effect annotations to be an upper bound on effect, we can require the operation $op$ to be in the effect set $\varepsilon$.

(T-Handle) shows the typing rule for the effect handling statement $\m{with} h_i \m{handle} c_i$. $c_i$ is a computation with effect type $\varepsilon$ and return type $\tau_A$. $h_i$ is a handler that contains a clause that handles operations $op^1 , \dots ,op^n$. For the return clause, given the type of variable $x$ is $\tau_A$, the type of $c^r$ must be $\{\varepsilon'\}\tau_B$. For the clause handling the operation $op^i$, which has the operation type $\tau_i \rightarrow \tau_i'$,  if variable $x$ has type $\tau_i$, and continuation has the type $\tau_i' \rightarrow \{\varepsilon'\}\tau_B$, then the handling computation $c^i$ must have the type $\{\varepsilon'\}\tau_B$. The effect type after handling, $\varepsilon'$ should contain all of the effects that are not handled by the handler.

(T-Embed) is very similar to (T-EmbedExp), where we use the type of the embedded computation and the type relation judgment to assign a type to the embedding. 

(T-EmbedOp) first computes the type of $c_i$ given that $y_i$ has the correct type. It is required that the effect annotation on the embedding is a part of the effect of $c_i$. And $op$ should be related to the effect annotation by the type relations.

\subsection{Type Relations}
\begin{figure}[H]
\footnotesize{
\noindent$\fbox{$\tau \leq_l \tau'$}$
\[
\begin{array}{c}

\infer[\textsc{(R-unit)}]
	{1 \leq_l 1}
	{} \quad

\infer[\textsc{(R-arrow)}]
	{\tau \rightarrow \sigma \leq_l \tau' \rightarrow \sigma'}
	{\tau \leq_l \tau' & \sigma \leq_l \sigma'}
  
\end{array} \\[3ex]
\]

\noindent$\fbox{$\sigma \leq_l \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(R-sigma)}]
	{\{\varepsilon\}\tau \leq_l \{\varepsilon'\}\tau'}
	{ \varepsilon \leq_l \varepsilon' & \tau \leq_l \tau' } \quad
  
\end{array} \\[3ex]
\]

\noindent$\fbox{$\varepsilon \leq_l \varepsilon$}$
\[
\begin{array}{c}

\infer[\textsc{(R-eff1)}]
	{\varepsilon \leq_i \varepsilon'}
	{ \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon')  } \quad

\infer[\textsc{(R-eff2)}]
	{\varepsilon \leq_{ll'} \varepsilon'}
	{  \varepsilon \leq_l \varepsilon'' &   \varepsilon'' \leq_{l'} \varepsilon' } \quad
\end{array} \\[3ex]
\]
}

\caption{Type Relations}
\label{fig-relation}
\end{figure}

Type relations ensure the soundness of abstraction. The goal of type relations is to prohibit embeddings from exporting incorrect effect abstractions. For example, if a i-computation uses an effect operation $flip : 1 \rightarrow bool$, which is an operation of effect \li{Nondet}, then whenever it is embedded in another agent, it should be annotated with effect \li{Nondet}, but should not  be annotated with the empty effect or other effects that does not contain \li{Nondet}.

The judgements for expression types are of the form $\tau \leq_l \tau$, where $l$ is a list of agents that provide the type abstraction information used by the relation. (R-Unit) shows that unit type relates to itself. (R-Arrow) relates two arrow types given that the input types and the output types are related,  To relate two computation types, we just need to ensure the effect types and return types are related. 

The relation for effect types does the actual work. By (R-EFF1), two effect types are related under a single agent $i$ if the first effect is a subset of the second effect after refinement by the type information provided by $i$. (R-EFF2) shows that by using type information from a list of agents, we can combine the chain of relation between effects.

\section{Safety Properties}
In this section, we state the standard type-safety theorems for the core calculus and a theorem that shows if an effect is abstract to a client, then the client would never handle the operation of that effect.  Since we split terms into expressions and computations, we state progress and preservation lemmas separately. The proofs to theorems stated in this section can be found in appendix \ref{appendix-alg}.

\subsection{Type Soundness}
We begin by stating the preservation and progress lemmas. The preservation lemma for expressions and computations are rather standard, except for the fact that we consider terms for each agent separately. In lemma \ref{preservation-exp}, if an i-expression steps to another i-expression, then the new expression should have the identical type as the original expression. Similarly, in lemma \ref{preservation-com}, the new computation should have the same effect type and return type as the original computation. 

\begin{lemma}[Preservation for Expressions]   \ \\
\label{preservation-exp}
For all agent $i$, if $\Gamma \vdash e_i : \tau$ and $e_i \mapsto e_i'$, then $\Gamma \vdash e_i' : \tau$.
\end{lemma} 

\begin{lemma}[Preservation for Computations] \ \\
\label{preservation-com}
For all agent $i$, if $\Gamma \vdash c_i : \{\varepsilon\} \tau$ and $c_i \longrightarrow c_i'$, then $\Gamma \vdash c_i' : \{\varepsilon\}\tau$
\end{lemma}

The progress lemma for expressions (lemma \ref{progress-exp}) is also standard. If an i-expression is well-typed, then it either steps to another expression or is already a value.
\begin{lemma}[Progress for Expressions] \ \\
\label{progress-exp}
For agent i, if $\varnothing \vdash e_i : \tau$ then either $e_i = v_i$ or $e_i \longrightarrow e_i'$.
\end{lemma}

The progress lemma for computations (lemma \ref{progress-com}) is a bit more involved. For any well-typed i-computation, there are four possibilities. Similar to expressions, a computation can evaluate to another computation. Otherwise, a computation could potentially be a return statement, an operation, or an embedded operation. The dynamic semantics ensures that these are the only possible final configurations for a computation.
 
\begin{lemma}[Progress for Computations]\ \\
\label{progress-com}
If $\varnothing \vdash c_i : \{\varepsilon\} \tau$ then either
\begin{enumerate}
\item  $c_i \longrightarrow c_i'$ 
\item  $c_i = \m{return} v_i$
\item $c_i = op(v_i; y_i.c_i')$
\item $c_i = [op]^\varepsilon_l(v_i; y_i.c_i')$
\end{enumerate}

\end{lemma}




\subsection{Abstraction Safety}

In this section, we prove a theorem on the correctness of effect abstraction. The intuition is that if a computation contains operations that are part of an opaque abstract effect, i.e., the definition of the effect is hidden from the agents in the computation, then the evaluation computation would not be affected by the operations.

We first define the notion of \emph{oblivious}. A computation is oblivious to an effect if and only if the effect is not known to the agent $i$, or any agent that lives inside the computation.
\begin{definition}
An  i-computation $c$ is \underline{oblivious} to effect label $f$ if $f \not\in Dom(\delta_i)$, and for all subexpression $[e]^\tau_j$ and subcomputation $[c]^\sigma_j$, $f \not\in Dom(\delta_j)$
\end{definition}

In the following theorem, we first define an equivalence relation. Two terms are equivalent if they are identical or the effect operations inside the terms are opaque to the agents in the terms. We show that two equivalent terms will stay equivalent after evaluation.
\begin{theorem} 

Let $c_1$ and $c_2$ be computations that are oblivious to the effect $f$.  If $c_1 \approx c_2$, $c_1 \rightarrow c_1'$, $c_2 \rightarrow c_2'$, then $c_1' \approx c_2'$. Furthermore,  If $e_1, e_2$ oblivious to f, $e_1 \approx e_2$, $e_1 \rightarrow e_1'$, $e_2 \rightarrow e_2'$, then $e_1' \approx e_2'$

The relation $\approx$ is defined as follows:
\begin{figure}[htb]
\flushleft
\footnotesize{

$\fbox{$e \approx e$}$
\[
\begin{array}{c}
\infer[\textsc{(R-Var)}]{x \approx x}
{} \qquad \infer[\textsc{(R-Unit)}]{() \approx ()}{} \\[3ex]
\infer[\textsc{(R-Lam)}]{\lambda x:\tau.\ c \approx \lambda x:\tau.\ c'}{c \approx c'} \qquad
\infer[\textsc{(R-EmbedExp)}]{[e]^\tau_l \approx [e']^\tau_l}{e \approx e'}
\end{array}
\]


$\fbox{$c \approx c$}$
\[
\begin{array}{c}
\infer[\textsc{(R-Ret)}]
  {\m{return} e \approx \m{return} e'}
  {e \approx e'}  
  \quad 
\infer[\textsc{(R-op)}]
  {op''(e; y.c) \approx op''(e'; y.c')}
  {e \approx e' & c \approx c'}
  \\[3ex]
\infer[\textsc{(R-Seq)}]
  {\m{do} x \leftarrow c \m{in} d \approx \m{do} x \leftarrow c' \m{in} d'}
  {c \approx c' & d  \approx d'} \quad
\infer[\textsc{(R-App)}]
  {e_1\ e_2 \approx e_1'\ e_2'}
  {e_1 \approx e_1' & e_2 \approx e_2'} \\[3ex]
\infer[\textsc{(R-Handle)}]
  {\m{with} h \m{handle} c \approx \m{with} h' \m{handle} c'}
  {h \approx h' & c \approx c'} \quad 
\infer[\textsc{(R-Embed)}]
  {[c_j]^\sigma_l \approx [c_j']^\sigma_l}
  {c_j \approx c_j'} \\[3ex]

\infer[\textsc{(R-Embedop1)}]
  {[op'']^\varepsilon_l(e; y.c) \approx [op'']^\varepsilon_l(e'; y.c')}
  {e \approx e' & c \approx c'}
  \quad
\infer[\textsc{(R-Embedop2)}]
  {[op]^\varepsilon_l(e; y.c) \approx [op']^\varepsilon_l(e'; y.c')}
  {e \approx e' & c \approx c' & \exists i \in l, \delta_i(f) = op, op'} \\[3ex]
\end{array}
\]

$\fbox{$h \approx h$}$
\[
\begin{array}{c}
\infer[\textsc{(R-Handler)}]{\begin{gathered} \{\m{return} x \mapsto c_r, op_1(x_1, k_1) \mapsto c_1, \dots, op_n(x_n, k_n) \mapsto c_n\} \approx \\\{\m{return} x \mapsto c_r', op_1(x_1, k_1) \mapsto c_1', \dots, op_n(x_n, k_n) \mapsto c_n'\}  
 \end{gathered} }{ c_r \approx c_r' & c_1 \approx c_1', \dots c_n \approx c_n'} 
\end{array}
\]


}
\caption{Definition of equivalence relation $\approx$}
\end{figure}




\begin{proof}(Sketch) By induction on derivation of $c_1 \approx c_2$ and $e_1 \approx e_2$
\begin{enumerate}
\item R-Ret:
  The only reduction rule that applies is E-Ret, so we have $e_1 \longrightarrow e_1'$ and $e_2 \longrightarrow e_2'$. By IH, we have $e_1' \approx e_2'$. Then the result follows by R-Ret
\item R-Op: The only reduction rule that applies is E-Op. The result is immediate by IH.
\item R-Seq: If the reduction rule is E-Seq1, then result is immediate by IH. 

If the reduction rule is E-Seq2. Then we have $c_1 = \m{do} x \leftarrow \m{return} v_1 \m{in} d_1$, $c_2 = \m{do} x \leftarrow \m{return} v_2 \m{in} d_2$. By inversion, we have $v_1 \approx v_2$ and $d_1 \approx d_2$. So we have $\{v_1/x\}d_1 \approx \{v_2/x\}d_2$.

If the reduction rule is E-Seq3, then $c_1 = \m{do} x \leftarrow op(v_1; y. k_1) \m{in} d_1$, $c_2= \m{do} x \leftarrow op(v_2; y. k_2) \m{in} d_2$. By inversion, we have $k_1 \approx k_2$ and $d_1 \approx d_2$. So $\m{do} x \leftarrow k_1 \m{in} d_1 \approx \m{do} x \leftarrow k_2 \m{in} d_2$. So $op(v_1; y. \m{do} x \leftarrow k_1 \m{in} d_1) \approx op(v_2; y. \m{do} x \leftarrow k_2 \m{in} d_2)$. The proof is similar for rule E-Seq4.

\item R-App: The cases for reduction rules E-App1 and E-App2 follows by IH. If reduction rule is E-App3. Then $c_1 = (\lambda x:\tau.\ d_1)\ v_1$ and $c_2 = (\lambda x:\tau.\ d_2)\ v_2$. By inversion we have $d_1 \approx d_2$ and $v_1 \approx v_2$. So we have $\{v_1/x\}d_1 \approx \{v_2/x\}d_2$.

\item R-Handle: If reduction rule is E-Handle1, then result follows by IH. 

If the reduction rule is E-Handle2. Then $c_1 = \m{with} h_1 \m{handle} \m{return} v_1$ and $c_2 = \m{with} h_2 \m{handle} \m{return} v_2$. By inversion we have $h_1 \approx h_2$, $v_1 \approx v_2$.  Let $\m{return} c_{r1} \in h_1$ and $\m{return} c_{r2} \in h_2$. By inversion we have $c_{r1} \approx c_{r2}$. So $\{v_1/x\}c_{r1} \approx \{v_2/x\}c_{r2}$.

If the reduction rule is E-Handle3. Then $c_1 = \m{with} h_1 \m{handle} op(v_1; y_1. c_1)$, and  $c_2 = \m{with} h_2 \m{handle} op(v_2; y_2. c_2)$. By inversion we have $h_1 \approx h_2$, $v_1 \approx v_2$, and $c_1 \approx c_2$. Let $op(x_1; k_1) \mapsto c_1' \in h_1$ and  $op(x_2; k_2) \mapsto c_2' \in h_2$. By inversion on R-Handler we have $c_1' \approx c_2'$. Then we can conclude that the evaluated computations are still equivalent: $$ 
\begin{gathered}
\{v_1 / x_1\} \{(\lambda y_1: \tau_B.\m{with} h_1 \m{handle} c_1)/k\}c_1' \approx 
\\ \{v_2 / x_2\} \{(\lambda y_2: \tau_B.\m{with} h_2 \m{handle} c_2)/k\}c_2'
\end{gathered}$$ 

If the reduction rule is E-Handle4. Then $c_1 = \m{with} h_1 \m{handle} op(v_1; y. k_1)$ and $c_2 = \m{with} h_2 \m{handle} op(v_2; y.k_2) $. By inversion we have $v_1 \approx v_2$, $k_1 \approx k_2$ and $h_1 \approx h_2$. Then by equivalence rules we have $c_1' \approx c_2'$. The case for E-Handle5 is similar. 

\item R-Embed: If reduction is E-Embed1,  result is immediate by IH. If reduction rule is E-Embed2, then $c_1 = [\m{return} v_1]^{\{\varepsilon\}\tau}_l$ and $c_2 = [\m{return} v_2]^{\{\varepsilon\}\tau}_l$. It is easy to see $[v_1]^\tau \approx [v_2]^\tau$. So the result holds.

If the reduction rule is E-Embed3, Then $c_1 = [op(v_1; y. k_1)]{\{\varepsilon\}\tau}_l$ and $c_2 = [op(v_2; y. k_2)]^{\{\varepsilon\}\tau}_l$. By inversion we have $v_1 \approx v_1$, $k_1 \approx k_2$. Then by equivalent rules we have $c_1' \approx c_2'$. Same arguments apply for E-Embed4.

\item R-EmbedOp1: If reduction rule is E-EmbedOp1, then result follows by IH. If reduction rules is E-EmbedOp2 or E-EmbedOp3, reduction does not affect terms except effect annotation, so the equivalence relation still hods after reduction.

\item R-EmbedOp2: Reduction rules E-EmbedOp1 and E-EmbedOp2 are similar to the previous case. If the reduction rule is E-EmbedOp3, then by R-EmbedOp2, the operations $op$ and $op'$ are exported as effect $f$ by some agent, and since current agent is oblivious to $f$, this case is impossible.

\end{enumerate}


\end{proof}


\end{theorem}

\pagebreak
\section{Translation of the Abstraction Problem}
In this section we show the process of evaluation of the example program presented in \ref{sec-motivation}. The original example could be rewritten  as follows:
\begin{lstlisting}[mathescape = true]
op : 1 -> 1
  
module b: B
  effect f = op
  def m() : {f} Unit
    op ()
  def handler(c: 1 -> {f} 1) : {} Int = 
    handle c () with
    | op () -> 1
    | return _ -> 0
\end{lstlisting}

The operation \li{op} is defined globally, and the module \li{b} defines effect \li{f} to be equivalent to \li{op},  an effectful method \li{m}, and an handler method \li{method}. The example program that we will evaluate is written as follows. The handler method from module \li{b} is invoked, and the argument is a computation that calls the method \li{b.m}, which is surrounded by a handler that handles \li{op}. 
\begin{lstlisting}[mathescape = true]
b.handler(
  () => handle b.m() with
          | op -> resume ()
          | return _ -> ()
 )
 \end{lstlisting}
 Then we rewrite the example program in our agent-based calculus: Since the code is a client of \li{b}, any method call from the module \li{b} should be surrounded by an embedding.  So the handler functions is wrapped in an embedding with type annotation \li{(1 -> \{f\} -> 1) -> Int}, and the handled function in the argument is also embedded with an annotation \li{1 -> \{f\} 1}. In the following evaluation process we assume that there is an agent \li{b} that represents the module \li{b}, and an agent \li{a} that represents the client code that invokes functions from module \li{b}

\begin{lstlisting}[mathescape = true]
// Translation of Example Program
[$\lambda$c: 1 -> {f} 1. 
  handle c() with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{(1 \rightarrow \{f\} 1) \rightarrow \{\} int}_b$
($\lambda$_:1. 
  handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
  | op(x, k) -> k ()
  | return _ -> return ())
 \end{lstlisting}
 
 Then according to the dynamic rules, we evaluate the handler function to a value that is not embedded. The program is therefore evaluated to 
 \begin{lstlisting}[mathescape = true]
 ($\lambda$c: 1 -> {f} 1. 
  [handle [c]$^{1 \rightarrow \{f\} 1}_a$  () with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$)
($\lambda$_:1. 
  handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
  | op(x, k) -> k ()
  | return _ -> return ())
  \end{lstlisting}
 
Since the function is evaluated to a value, we can perform a $\beta$-reduction:
 \begin{lstlisting}[mathescape = true]
  [handle 
     [$\lambda$_:1. 
      handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{1 \rightarrow \{f\} 1}_a$  () 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
 \end{lstlisting}
 
 Now we need to evaluate the outter-most handle computation in the embedding. The first step is to evaluate the handled computation, which is a function application. We first evaluate the function
  \begin{lstlisting}[mathescape = true]
[handle 
     $\lambda$_:1. 
      [handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{\{f\} 1}_a$  () 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
 \end{lstlisting}
 Then we pass in the argument, which is a unit value
  \begin{lstlisting}[mathescape = true]
[handle 
      [handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{\{f\} 1}_a$ 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
\end{lstlisting}  
Then we evaluate the inner handling computation. Since the inner handling computation is evaluated as a client code and the operation \li{op} in an embedding from module \li{b}, the operation will not be handled by the current handler. Instead, it would be lifted out of the handler.

%  \begin{lstlisting}[mathescape = true]
%[handle 
%      [handle $\lambda$_:1. [op()]$^{\{f\} 1}_b$ () with
%      | op(x, k) -> k ()
%      | return _ -> return () ]$^{\{f\} 1}_a$ 
%  with 
 % | op(x, k) -> return 1
  %| return x -> return 0)]$^{ \{\} int}_b$
  
%\\steps--->
%[handle 
 %     [handle [op()]$^{\{f\} 1}_b$ with
  %    | op(x, k) -> k ()
  %    | return _ -> return () ]$^{\{f\} 1}_a$ 
 % with 
 % | op(x, k) -> return 1
  %| return x -> return 0)]$^{ \{\} int}_b$
  
%\\steps--->
%[handle 
%     [handle op$^f_b$((), y.return y) with
 %     | op(x, k) -> k ()
 %     | return _ -> return () ]$^{\{f\} 1}_a$ 
 % with 
 % | op(x, k) -> return 1
 % | return x -> return 0)]$^{ \{\} int}_b$
 % \end{lstlisting}

  \begin{lstlisting}[mathescape = true]
[handle 
      [op$^f_b$((), y. handle return y with
                       | op(x, k) -> k ()
                       | return _ -> return () 
          )]$^{\{f\} 1}_a$ 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
  \end{lstlisting}
  
At this point since the operation \li{op} is lifted to the agent b, where the effect $f$ is transparent, the handler would be able to handle it. The result of this computation is \li{return 1}, because the continuation is discarded by the handler.
  \begin{lstlisting}[mathescape = true]
  [handle 
      op$^f_{ba}$((), y. [handle return y with
                       | op(x, k) -> k ()
                       | return _ -> return ()]$^{\{f\} 1}_a$ 
          )
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$   
\end{lstlisting}


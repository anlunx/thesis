% !TEX root = thesis.tex

\chapter{Abstract Algebraic Effects Via Embedding}

\section{Background and Motivation}

Algebraic effects (introduced by \citet{plotkin02}) and handlers (introduced by \citet{plotkin09}) are an approach to computational effects based on a premise that impure behavior arises from a set of operations, and are recently gaining popularity due to its ability to model various form of computational effects such as exceptions, mutable states, async-await, etc.

Modularity is a key concept that separates abstract algebraic effects from the traditional way of using monad to model effects in purely functional programming \cite{schrijvers19}. [Insert Reasons Here] 

However, similar to the restrictive strand of work on effects, few works on algebraic effects has investigated the algebraic effect system on a larger scale, where abstraction between program components is important. \citet{biernacki19} first studied abstraction of algebraic effects and handlers, presented a calculus equipped with existential algebraic effects and typed runtime coercions, and provided an implementation as a proof of concept. 


Abstract algebraic effects are first introduced in \cite{biernacki19}. Similar to abstract types, abstract effect signature allows program components to define abstract effect signatures that is opaque to other components in the system. The difference between concrete and abstract effect signatures lies in the ability for program components to handle them. If an effect signature is concrete to a program component, then the operations are accessible the component, and a handler can handles the effect by handling the operations in the signature. On the other hand, if an effect signature is abstract to one program component, then the component should not observe the operations defined in the effect signature, and is therefore unable to handle the effect. As abstraction is an important issue for module systems because it provides a separation of implementation details of functions from the interface, abstraction of algebraic effects provides a similar benefit for modularity because it helps separate the component operations from the effect signature, ensuring that the client can only uses the handler provided by the library to handle the effect.

The following code is a motivating example similar to the example in \cite{biernacki19} that illustrates the challenges of implementing abstract algebraic effects. \li{Nondet} is a globally defined effect signature. Then we define a module \li{m} with type \li{M} with an abstract effect \li{E}, a method \li{mflip}, and a handler method \li{handle}. The effect \li{E} is defined by \li{Nondet}, but is opaque to the outside world of the module, because \li{E} is defined as an abstract effect in the type \li{M}. The method \li{mflip} simply calls the \li{flip} operation, and the \li{handle} method handles the \li{flip} operation by returning \li{true}. 

\begin{lstlisting}[language=scala]  
effect Nondet {
    flip(): Bool  
}

type M
  effect E 
  def mflip() : {this.E} Bool
  def handler(Unit -> {this.E} Bool) : {} Bool
  
module m: M
  effect E = {Nondet}
  def mflip() : {this.E} Unit
    flip()
  def handle(c: Unit -> {this.E} Bool) : {} Bool = 
    handle c() with
    | flip() -> return true

m.handle(
  () => handle m.mflip() with
          | flip() ->  return false
 )

\end{lstlisting}

The last segment of the above example shows an client code of module \li{m} that calls the method \li{m.handle} and pass in an expression that encapsulate the call to \li{m.mflip} by another handler that handles the \li{flip} operation. Since the effect of the method \li{m.mflip} is abstract, the inner handler should not handle the operation inside \li{m.mflip}. Instead, the operation should be handled by the outer handler method \li{m.hanlde}. However, 

As we can see, the abstraction of effect signatures from type abstractions, since the erasure of type information would make the abstraction unsound. So we need a language that keep track of the information on effect abstraction during the evaluation of the program. In this work, we incorporate the method of syntactic type abstraction introduced by \citet{grossman00}, who use the notion of principals to track the flow of values with abstract types during the evaluation of a program. 

\section{Core Calculus}
\label{sec-core}
\subsection{Syntax}
\begin{figure}
\label{fig-syntax}
\begin{align*}
&(agents) &i, j &::= \{1 \dots n\}\\
&(lists) & l &::= i \mid il\\
&(value\ types) &\tau &::= unit \mid \tau \rightarrow \sigma\\
&(computation\ types) &\sigma &::= \{\varepsilon\}\tau\\
&(effect\ types) &\varepsilon &::= \cdot \mid f, \varepsilon \mid op, \varepsilon\\
&(i\  values) &{v_i} &::= ()_i \mid \lambda x_i:\tau.\ c_i\\
&(i\ expression) &e_i &::= x_i \mid v_i \mid [e_j]^\tau_l \\
&(i\ computation) &c_i &::= \texttt{return}\ e_i \mid op(e_i, y.c_i) \mid \texttt{do}\ x \leftarrow c_i\ \texttt{in}\ c_i' \mid e_i\ e_i' \mid \texttt{with}\ h_i\ \texttt{handle}\ c_i\\
 &\ &\mid\ &[c_j]^\sigma_l \mid [op]^\varepsilon_l (e_i, y_i.c_i)\\
&(i\ handler) &h_i &::= \texttt{handler}\ \{\texttt{return}\ x_i \mapsto c^r_i, op^1(x_i^1, k^1) \mapsto c_i^1 \dots  op^n(x_i^n, k^n) \mapsto c_i^n\}  
\end{align*}
\caption{Syntax for multi-agent calculus}
\end{figure}

This section describes a variant of the simply typed lambda calculus that maintains a syntactic distinction between agents throughout evaluation. Figure \ref{fig-syntax} gives the syntax of our calculus. As our previous discussion, it is crucial to keep track of the effect abstraction information during the evaluation of the program. It is therefore natural to divide the code into agents, and allow each agent to export abstract effect signatures. We assume that there are $n$ agents, and use variables $i, j, k$ to range over the set of agents. 

Every term in this language is assigned to an agent. And terms are split into inert expressions and potentially effectful computations, following an approach called \emph{fine-grain call-by-value}, introduced by \citet{levy03}. We use the notation \emph{i-expression} and \emph{i-computation} to denote expressions and computations in the agent i. We use subscripts to indicate a term is assigned to an agent, however, we will omit the subscript if the agent the term belongs to is not important or obvious in the context.

An \emph{i-value} is an \emph{i-expression} that cannot further reduce. There are two forms of \emph{i-value}: the unit $()$, and the lambda abstraction $\lambda x_i: \tau.\ c_i$. \emph{i-expressions} include variable $x_i$, value $v_i$, and embedded expressions $[e_j]^\tau_j$. \emph{i-computations} are the terms that can potentially cause effects, and consists of return statement $\m{return} e_i$, operation call $op(e_i; y_i.c_i)$, sequencing $\m{do} x_i \leftarrow c_i \m{in} c_i'$, application $e_i\ e_i'$, handling $\m{with} h_i \m{handle} c_i$, embedded computation $[c_j]^\sigma_j$, and embedded operation call $[op]^\varepsilon_l(e_i; y_i.c_i)$. There are few things worth mentioning: 
\begin{enumerate}
\item[] \textbf{Sequencing}: in $\m{do} x \leftarrow c \m{in} c'$, we first evaluate $c$,  bind the return value of $c'$ to x and then evluate $c_2$
\item[] \textbf{Operation Calls}: The call $op(e; y.c)$ passes the parameter $e$ to the operation $op$,  binds the return value of the operation call to $y$, and continue by evaluating the computation $c$. Note that the encompassing handler could potentially change the behavior of the operation.
\item[] \textbf{Embeddings}: the term $[e_j]^\tau_j$ is i-expression that contains an embedded j-expression, with a type $\tau$ exported by $j$. Similarly, $[c_j]^\sigma_j$ is an embedded j-expression with exported type $\sigma$ 
\item[] \textbf{Embedded Operations}: The embedded operation $[op]^\varepsilon_l(e; y.c)$ is a operation call that is annotated with effect $\varepsilon$. $l$ is a list of agents that have contributed to the formation of the annotation. We will describe this in more detail later.
\end{enumerate}

Similar to terms, types are also divided into expression types and computation types. There are two forms of expression types $\tau$: the unit type $1$, and the arrow type $\tau \rightarrow \sigma$. As for the computation type $\sigma$, there is only one form: $\{\varepsilon\}\tau$: where $\varepsilon$ is a set of effect that the computation might induce, and $\tau$ is the type of the return value of the computation. 

The effect type $\varepsilon$ represents an unordered set of effects that can be empty $\cdot$. A effect type can be extended by either an effect label $f$, or an operation $op$.

The i-handler $h_i$ must contain a return clause that handles the case when the handled computation directly returns a value. It may also contain clauses that handle operations. For example, the clause $op(x, k) \mapsto c$ handles the operation $op$. More details can be found in the dynamic semantics section.

\subsection{Agent Specific Type Information}
We use agents to model a module system where each module can have private information about effect abstraction. Each agent in our language has limited knowledge of effect abstraction. For example, an agent i might knows that effect \li{Nondet = flip(): Bool}, and an agent $j$ does not have this information. As a result, agent i would be able to handle a computation with effect \li{Nondet}, while the agent j would not be able to do that. Furthermore, we need to ensure the consistency the information on effect abstraction, that is, agent j should not think that the effect \li{Nondet = read(): String}, which would contradict with the knowledge of agent i. 

The model of effect abstraction information is similar to the model of type information in \cite{grossman00}. To capture effect abstraction information, each agent $i$ has a partial function $\delta_i$ that maps an effect label to an effect type. There are two requirement for these maps: (1) For each effect label $f$, the if there are two agents that knows the implementation of the effect $f$, then there knowledge about the implementation must be the same. (2) For each effect label $f$, there is a unique and most concrete interpretation of $f$. We would not allow the effect label $f$ itself to appear in the implementation of $f$. Examples like $\delta_i(f) = \{f\}$ would be rejected.

\begin{definition}
A set $\{\delta_1, \dots, \delta_n\}$ of maps from effect labels to effects is \underline{compatible} if
\begin{enumerate}
\item For all $i, j \in 1 \dots n$ if $f \in Dom(\delta_i) \cap Dom(\delta_j)$, then $\delta_i(f) = \delta_i(j)$.
\item Effect labels can be totally ordered such that for every agent $i$ and effect label $f$, all effect labels in $\delta_i(f)$ precede $f$.
\end{enumerate}
\end{definition}

Then we define the a total function $\Delta_i$ that refines an effect type:
\begin{definition}
\begin{align*}
\Delta_i(\cdot) &= \cdot \\
\Delta_i(op, \varepsilon) &= op, \Delta_i(\varepsilon) \\
\Delta_i(f, \varepsilon) &= 
    \begin{cases}
      f, \Delta_i(\varepsilon) & \text{if}\ f \not\in Dom(\delta_i)  \ \\
      \varepsilon', \Delta_i(\varepsilon) & \text{if}\ \delta_i(f) = \varepsilon'
    \end{cases}
\end{align*}
\end{definition}

The definition of compatibility ensures that there is a fixpoint for repeatedly refining an effect label $f$ using the function $\Delta_i$. We call such fixpoint $\overline{\Delta_i}(f)$.

\begin{definition}
$\overline{\Delta_i}(f) = \varepsilon$ if there is some $n \geq 0$
\[
    \underbrace{\Delta_i(\dots (\Delta_i(f) \dots )}_\text{n applications}   = 
    \underbrace{\Delta_i(\dots (\Delta_i(f) \dots )}_\text{n+1 applications}   = \varepsilon
 \]
 \end{definition}
 
 We assume that the type information for operations are public to all agents. The type  for an operation $op$ is contained a separate map $\Sigma$, which maps an operation $op$ to an arrow type $\tau_A \rightarrow \tau_B$. Note that this is different from the function type in our calculus, which has the form $\tau \rightarrow \sigma$.




\section{Operational Semantics}
\begin{figure}[t]
\footnotesize{


$\fbox{$e \longrightarrow e'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Congruence)}]
  {[e_j]^\tau_l \longrightarrow [e_j']^\tau_l}
  {e_j \mapsto e_j'} \quad 

\infer[\textsc{(E-Unit)}]
  {[()_j]^{unit}_l \longrightarrow ()_i}
  {} \\[3ex]
  
\infer[\textsc{(E-Lambda)}]
  {[\lambda x_j : \tau'.\ c_j]^{\tau \rightarrow \sigma}_{j} \longrightarrow \lambda x_i : \tau.\ [\{[x_i]^{\tau'}_{i}/x_j\}c_j]^\sigma_{jl}}
  {} \\[3ex]
\end{array}
\]
}
\caption{Operational Semantics for Expressions}
\label{fig-op1}

\end{figure}

\begin{figure}[p]
\footnotesize{

$\fbox{$c \longrightarrow c'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Ret)}]
  {\texttt{return}\ e_i \longrightarrow \texttt{return}\ e_i'}
  {e_i \mapsto e_i'} \quad
  
\infer[\textsc{(E-Op)}]
  {op(e_i,y_i.c_i) \longrightarrow op(e_i', y_i, c_i)}
  {e_i \mapsto e_i'} \\[3ex]
 
 
\infer[\textsc{(E-EmbedOp1)}]
{[op]^\varepsilon_l(e_i; y_i.c_i) \longrightarrow [op]^{\varepsilon}_l(e_i'; y_i.c_i) }
{e_i \longrightarrow e_i'} \quad
 
\infer[\textsc{(E-EmbedOp2)}]
{[op]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow [op]^{\varepsilon'}_l(v_i; y_i.c_i) }
{\overline{\Delta_i}(\varepsilon) = \varepsilon'} \\[3ex]

\infer[\textsc{(E-EmbedOp3)}]
{[op]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow op(v_i; y_i.c_i) }
{\Delta_i(\varepsilon) = \varepsilon & op \in \varepsilon} \quad

\infer[\textsc{(E-EmbedOp4)}]
{[op]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow [op]^{\varepsilon \setminus op'}(v_i; y_i.c_i) }
{\Delta_i(\varepsilon) = \varepsilon & op \not\in \varepsilon & op' \in \varepsilon} \\[3ex]


\infer[\textsc{(E-App1)}]
  {e_i\ e_i' \longrightarrow e_i''\ e_i'}
  {e_i \longrightarrow e_i''}  \quad
  
\infer[\textsc{(E-App2)}]
  {v_i \ e_i \longrightarrow v_i\ e_i'}
  {e_i\longrightarrow e_i'}  \quad
  
\infer[\textsc{(E-App3)}]
  {(\lambda x_i:\tau.\ c_i) \ v_i \longrightarrow \{v_i/x_i\}c_i}
  {} \\[3ex]
  
  
\infer[\textsc{(E-Seq1)}]
  {\texttt{do}\ x \leftarrow c_i\ \texttt{in}\ c_i' \longrightarrow \texttt{do}\ x \leftarrow c_i''\ \texttt{in} c_i'}
  {c_i \longrightarrow c_i''}  \quad
  
\infer[\textsc{(E-Seq2)}]
  {\texttt{do}\ x \leftarrow \texttt{return}\ v_i \ \texttt{in}\ c_i' \longrightarrow \{v_i/x\} c_i'}
  {} \\[3ex]
  
\infer[\textsc{(E-Seq3)}]
  {\texttt{do}\ x \leftarrow op_i(v_i; y_i.c_i) \texttt{in}\ c_i' \longrightarrow op_i(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i')}
  {} \\[3ex]
  
\infer[\textsc{(E-Seq4)}]
  {\texttt{do}\ x \leftarrow [op_j]^\varepsilon_l(v_i; y_i.c_i) \texttt{in}\ c_i' \longrightarrow [op_j]^\varepsilon_l(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i')}
  {\Delta_i(\varepsilon) = \varepsilon & op \not \in \varepsilon} \\[3ex]
  

  
 \infer[\textsc{(E-Handle1)}]
  {\m{with} h_i \m{handle} c_i \longrightarrow \m{with} h_i \m{handle} c_i' }
  {c_i \longrightarrow c_i'} \quad
  
\infer[\textsc{(E-Handle2)}]
  {\m{with} h_i \m{handle} \m{return} v_i \longrightarrow \{v_i/x_i\}c_i' }
  {\m{return} x_i \mapsto	c_i' \in h_i} \\[3ex]
  
\infer[\textsc{(E-Handle3)}]
  {\m{with} h_i \m{handle} op(v_; y_i.c_i) \longrightarrow \{v_i/x_i\} \{(\lambda y: \tau_B.
   \m{with} h_i\m{handle} c_i) / k\}c_i' }
  {op(x_i; k) \mapsto c_i' \in h_i & \Sigma(op) = \tau_A \rightarrow \tau_B} \\[3ex]
 
 
\infer[\textsc{(E-Handle4)}]
  {\m{with} h_i \m{handle} op(v_i, y_i.c_i) \longrightarrow op(v_i; y_i. \m{with} h_i \m{handle} c_i))}
  {op(x_i; k) \mapsto c_i' \not\in h_i } \\[3ex]
  
\infer[\textsc{(E-Handle5)}]
  {\m{with} h_i \m{handle} [op]^\varepsilon_l(v_i, y_i.c_i) \longrightarrow [op]^\varepsilon_l(v_i; y_i. \m{with} h_i \m{handle} c_i))}
  {\Delta_i(\varepsilon) = \varepsilon & op \not \in \varepsilon} \\[3ex]
  
\infer[\textsc{(E-Embed1)}]
{[c_j]^\sigma_l \longrightarrow [c_j']^\sigma_l}
{c_j \longrightarrow c_j'} \quad 



\infer[\textsc{(E-Embed2)}]
{[\m{return} v_j]^{\{\varepsilon\}\tau}_l \longrightarrow \m{return} [v_j]^\tau_l}
{} \\[3ex]

\infer[\textsc{(E-Embed3)}]
{[op_j(v_j; y_j.c_j)]^{\{\varepsilon\}\tau}_l \longrightarrow [op_j]^\varepsilon_l([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_l)}
{ \Sigma(op) = \tau_A \rightarrow \tau_B} \\[3ex]

\infer[\textsc{(E-Embed4)}]
{[[op_k]^{\varepsilon'}_{l}(v_j; y_j.c_j)]^{\{\varepsilon\}\tau}_j \longrightarrow [op_k]^\varepsilon_{lj}([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_j)}
{ \Sigma(op) = \tau_A \rightarrow \tau_B& \Delta_j(\varepsilon') = \varepsilon' & op \not \in \varepsilon'} \\[3ex]



\end{array}
\]

}
\caption{Operational Semantics for Computations}
\label{fig-op2}

\end{figure}

The reduction rules for terms are dependent on the agent of the terms. Figure \ref{fig-op1} shows that operational semantics for expressions of agent i. (E-Congurence) shows that a j-expression embedded agent-i should be evaluated using the reductions rules for agent j first. The (E-Unit) and (E-Lambda) rules show that we can lift an embedded j-value to agent i, so the value becomes an i-value. The (E-Unit) rule simply lifts the unit value out of the embedding. The (E-Lambda) rule is more interesting: The value embedded is a lambda expression of agent j. We lift the argument out of the embedding. However, the type annotating the argument is changed from $\tau'$ to the exported argument type $\tau$, because the reduced expression should have the exported type $\tau \rightarrow \sigma$. The body of the reduced expression is an embedded j-computation, so the variable $x_i$ should be encapsulated by an embedding, because any i-term should be embedded in a j-term. We annotate $x_i$ with type $tau'$ because the original lambda function expects a value of type $tau'$. 

Figure \ref{fig-op2} shows the reduction rules for i-computations. (E-Ret) is the congruence rule that evaluates the expression in return statement. (E-Op) evaluates the input argument for the operation call. Note that there are no reduction rules for operation calls because the semantics for operations are defined by the handler encapsulating it. 

(E-EmbedOp1) evaluates the argument expression to an embedded operation. (E-EmbedOp2) refines the effect annotation of an operation. (E-EmbedOp3) lifts the operation out of an embedding when the annotation contains the operation, because the agent i has enough information about effect abstraction to handle the operation. Note that we require that the effect annotation cannot be further refined, in order to ensure determinism of evaluation. (E-EmbedOp4) removes an operation that is not $op$ out of the effect annotation, as this is helpful in our proof of type soundness.

(E-App1), (E-App2) and (E-App3) are standard call-by-value semantics for applications. (E-Seq1) evaluates the first computation in a sequence of computations. (E-Seq2) binds the return value of the first computation to a variable in the second computation. (E-Seq3) witnesses an operation call as the first computation in a sequence. Since there is no way to further evaluate an operation right away, we propagate the operation call outwards and defer further evaluation to the continuation of the call. (E-Seq4) is similar to (E-Seq3), and requires that the effect annotation on the embedding to be most precise. 

(E-Handle1) simply evaluates the computation encapsulated by the handler. In (E-Handle2), the computation returns a value, so we substitute the value into the computation of the clause that handles the return statement in the handler. (E-Handle3) shows that case when the handler $h_i$ has a matching clause for the operation $op$. We substitute the argument $v_i$ for $x_i$, and substitute the continuation of the operation for $k$. The continuation function receives an argument of type $\tau_B$, which is the result type of the operation $op$, and computes the continuation of the operation $c_i$, but encapsulating it with the handler $h_i$. The (E-Handle4) shows the case when the operation is not handled by the handler, so we propagate the operation outwards to wait for another handler to handle it. The (E-Handler5) ensures that abstracted effects are not handled: If the current agent cannot refine the effect annotation, then the operation is abstract and cannot be handled, and is therefore propagated outward. 

(E-Embed1) is the congruence rule for embedded computations. (E-Embed2) lifts the return statement out of the embedding. We can safely remove the effect annotation $\varepsilon$ because the returned value $v_j$ cannot cause any effect. 

(E-Embed3) lifts an operation call out of the embedding. We annotate the operation with the effect annotation of the whole computation. Since the argument value for $op$ is a j-value, we need to embed it as a i-value, and annotate it with type $\tau_A$. The continuation $c_j$ is still embedded, and we substitute the embedded variable $y_i$ for $y_j$, because $y_i$ should be an embedded i-value in a j-value.

The (E-Embed4) rule is very similar to (E-Embed3) with one difference being that $op$ is already embedded. In this case, we override the annotation on $op$ with the annotation for the whole computation, and update the agent list in the subscript of the operation. We add $j$ to the agent list because the agent j have contributed to the effect annotation of the operation.

\section{Static Semantics}
\subsection{Typing Rules}

\begin{figure}[t]
\footnotesize{
\noindent$\fbox{$\Gamma \vdash e_i : \tau$}$
\[
\begin{array}{c}

\infer[\textsc{(T-unit)}]
  {\Gamma \vdash ()_i : 1}
  {} \quad 

\infer[\textsc{(T-var)}]
  {\Gamma \vdash x_i : \Gamma(x_i)}
  {} \quad 

\infer[\textsc{(T-lam)}]
  {\Gamma \vdash (\lambda x_i: \tau.\ c_i) : \tau \rightarrow \sigma}
  {\Gamma, x_i:\tau \vdash c_i : \sigma} \\[3ex]
  
\infer[\textsc{(T-EmbedExp)}]
  {\Gamma \vdash [e_j]^\tau_l : \tau}
  {\Gamma \vdash e_j : \tau' & \Gamma \vdash \tau' \leq_{li} \tau} \quad  
\end{array} \\[3ex]
\]


\noindent$\fbox{$\Gamma \vdash c_i : \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(T-ret)}]
  {\Gamma\vdash \m{return} e_i : \{\varepsilon\}\tau }
  {\Gamma\vdash e_i : \tau & \Delta_i(\varepsilon) = \varepsilon} \quad 
  
\infer[\textsc{(T-op)}]
  {\Gamma\vdash op(e_i; y_i.c_i) : \{\varepsilon\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon\}\tau & op \in \Delta_i(\varepsilon)} \\[3ex]


\infer[\textsc{(T-seq)}]
  {\Gamma\vdash \m{do} x_i \leftarrow c_i \m{in} c_i' : \{\varepsilon\}\tau' }
  {\Gamma \vdash c_i : \{\varepsilon\}\tau & \Gamma, x_i:\tau \vdash c_i': \{\varepsilon\}\tau'} \quad 
  
  
\infer[\textsc{(T-app)}]
  {\Gamma\vdash e_1\ e_2\ : \sigma }
  {\Gamma \vdash e_1 : \tau \rightarrow \sigma & \Gamma \vdash e_2 : \tau} \\[3ex]
  
\infer[\textsc{(T-handle)}]
  {\Gamma\vdash \m{with} h_i \m{handle} c_i: \{\varepsilon'\} \tau_B}
  {\begin{gathered}
  h_i = \{\m{return} x \mapsto c^r, op^1(x;k) \mapsto c^1, \dots, op^n(x;k) \mapsto c^n \}\\
  \Gamma, x: \tau_A \vdash c^r : \{\varepsilon'\}\tau_B \quad
  \left\{ \Sigma(op^i) = \tau_i \rightarrow \tau_i'  \quad \Gamma, x:\tau_i, k:\tau_i' \rightarrow \{\varepsilon'\}\tau_B \vdash c^i: \{\varepsilon'\}\tau_B    \right\}_{1 \leq i \leq n} \\
  \Gamma \vdash c_i : \{\varepsilon\}\tau_A \quad \varepsilon \setminus \{op^i\}_{1 \leq i \leq n} \subseteq \varepsilon'
  \end{gathered}} \\[3ex]
  
\infer[\textsc{(T-Embed)}]
  {\Gamma\vdash [c_j]^\sigma_l : \sigma }
  {\Gamma \vdash c_j : \sigma' & \Gamma \vdash \sigma' \leq_{li} \sigma  } \\[3ex]
  
\infer[\textsc{(T-EmbedOp)}]
  {\Gamma\vdash [op]^\varepsilon_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau & \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon') & \Gamma \vdash op \leq_{li} \varepsilon} \\[3ex]
  
\end{array} \\[3ex]
\]
}


\caption{Static Semantics}
\label{wrap-static}
\end{figure}

Figure \ref{wrap-static} shows the static semantics of the core-calculus. Static semantics contains typing rules for both expressions and computations. Note that the type rules depend on the agent each expression or computation belongs to. 

The rule (T-Unit) assigns the unit type to a unit value. (T-Var) looks up a type of a variable from the context. (T-Lam) is the standard rule for typing a lambda function. Note that the body of a lambda is computation, so we need use the typing judgement for computation in the premise of this rule. (T-EmbedExp) assigns type to expression embeddings: The embedding has type $tau$ if the embedded expression $e_j$ is assigned to the type $\tau'$, and $tau$ is related to $tau'$ by the list $li$. We will elaborate on type relations later. 

(T-Ret) assign a type to a return statement: As expected, the expression part of the computation type matches the type of the returned expression. However we can annotate the return statement with an arbitrary effect set, because our type system does not describe the precise effect in computations, but gives the upper bound of effect in computations.  

(T-Op) shows the typing rule for operation calls. Again, since we allow effect annotations to be an unpper bound on effect, we can require the operation $op$ to be in the effect set $\varepsilon$.

(T-Handle) shows the typing rule for the effect handling statement $\m{with} h_i \m{handle} c_i$. $c_i$ is a computation with effect type $\varepsilon$ and return type $\tau_A$. $h_i$ is a handler that contains clause that handler operations $op^1 , \dots ,op^n$. For the return clause, given the type of variable $x$ is $\tau_A$, the type of $c^r$ must be $\{\varepsilon'\}\tau_B$. For the clause handling the operation $op^i$, which has the operation type $\tau_i \rightarrow \tau_i'$,  if variable $x$ has type $\tau_i$, and continuation has the type $\tau_i' \rightarrow \{\varepsilon'\}\tau_B$, then the handling computation $c^i$ must have the type $\{\varepsilon'\}\tau_B$. The effect type after handling, $\varepsilon'$ should contain all of the effects that are not handled by the handler.

(T-Embed) is very similar to (T-EmbedExp), where we use the type of the embedded computation and the type relation judgment to assign a type to the embedding. 

(T-EmbedOp) first computes the type of $c_i$ given that $y_i$ has the correct type. It is required that the effect annotation on the embedding is a part of the effect of $c_i$. And $op$ should be related to the effect annotation using the type relations.

\subsection{Type Relations}
\begin{figure}[H]
\footnotesize{
\noindent$\fbox{$\tau \leq_l \tau'$}$
\[
\begin{array}{c}

\infer[\textsc{(R-unit)}]
	{1 \leq_l 1}
	{} \quad

\infer[\textsc{(R-arrow)}]
	{\tau \rightarrow \sigma \leq_l \tau' \rightarrow \sigma'}
	{\tau \leq_l \tau' & \sigma \leq_l \sigma'}
  
\end{array} \\[3ex]
\]

\noindent$\fbox{$\sigma \leq_l \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(R-sigma)}]
	{\{\varepsilon\}\tau \leq_l \{\varepsilon'\}\tau'}
	{ \varepsilon \leq_l \varepsilon' & \tau \leq_l \tau' } \quad
  
\end{array} \\[3ex]
\]

\noindent$\fbox{$\varepsilon \leq_l \varepsilon$}$
\[
\begin{array}{c}

\infer[\textsc{(R-eff1)}]
	{\varepsilon \leq_i \varepsilon'}
	{ \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon')  } \quad

\infer[\textsc{(R-eff2)}]
	{\varepsilon \leq_{ll'} \varepsilon'}
	{  \varepsilon \leq_l \varepsilon'' &   \varepsilon'' \leq_{l'} \varepsilon' } \quad
\end{array} \\[3ex]
\]
}

\caption{Type Relations}
\label{wrap-static}
\end{figure}

Type relations ensures the soundness of abstraction. The goal of type relations is to prohibit embeddings from exporting incorrect effect abstractions. For example, if a i-computation uses an effect operation $flip : 1 \rightarrow bool$, it should annotate the computation with effect $Nondet$ when exporting the computation, but should not  annotate it with the empty effect.

The judgements for expression types are of the form $\tau \leq_l \tau$, where $l$ is a list of agents that provide the type abstraction information used by the relation. (R-Unit) shows that unit types relates to itself. (R-Arrow) relates two arrow types given that the input types and the output types are related,  To relate two computation types, we just need to ensure the effect types and return types are related. 

The relation for effect types does the actual work. By (R-EFF1), two effect types are related under a single agent $i$ if the first effect is a subset of the second effect after refined by the type information provided by $i$. (R-EFF2) shows that by using type information from a list of agents, we can combine the chain of relation between effects.

\section{Safety Properties}
In this section we state and prove the standard type-safety theorems for the core calculus.
\begin{lemma} (Substitution) \\
If $\Gamma, x_j : \tau' \vdash c_i : \sigma$ and $\Gamma \vdash e_j : \tau'$, then $\Gamma \vdash \{e_j/x_j\}c_i : \sigma$, and\\\
If $\Gamma, x_j : \tau' \vdash e_i : \tau $ and $\Gamma \vdash e_j : \tau'$, then $\Gamma \vdash \{e_j/x_j\}e_i : \tau$

\begin{proof}
By rule induction on $\Gamma \vdash e : \tau$ and $\Gamma \vdash c : \sigma$
\begin{enumerate}
\item[(T-Unit)] Trivial
\item[(T-Var)] Trivial
\item[(T-Lam)] 
$$
\infer[\textsc{(T-lam)}]
  {\Gamma, x_j : \tau'  \vdash (\lambda x_i: \tau.\ c_i) : \tau \rightarrow \sigma}
  {\Gamma,x_j : \tau',  x_i:\tau \vdash c_i : \sigma} 
$$
By IH, we have $\Gamma, x_i:\tau \vdash \{e_j/x_j\}c_i : \sigma$\\
Then by (T-Lam) we have $\Gamma \vdash (\lambda x_i : \tau.\ \{e_j/x_j\}c_i) : \sigma$.\\
Which is equivalent to $\Gamma \vdash \{e_j/x_j\}(\lambda x_i : \tau.\ c_i) : \sigma$.
\item[(T-EmbedExp)] By inversion and IH
\end{enumerate}

\end{proof}

\end{lemma}

\begin{lemma} 
\label{lemma-exact}
If $\Gamma \vdash c_i : \{\varepsilon\}\tau$ then $\overline{\Delta_i}(\varepsilon) = \varepsilon$
\begin{proof}
By induction on derivation of $\Gamma \vdash c : \sigma$. (T-Ret) has a premise the ensures the lemma is correct. For other rules, the result is immediate by applying IH.

\end{proof}
\end{lemma}

\begin{lemma}
\label{lemma-minus}
If $\varepsilon \leq_l \varepsilon'$, then $\varepsilon \setminus op \leq_l \varepsilon' \setminus op$
\begin{proof}
By induction on $\varepsilon \leq_l \varepsilon$. The proof is straightforward.
\end{proof}

\end{lemma}

\begin{lemma}
\label{lemma-relation}
If $op \leq_{l} \varepsilon$, then $op \leq_{l} \varepsilon \setminus op'$
\begin{proof}
By induction on the derivation of $\varepsilon \leq_l \varepsilon$. If (R-Eff1) is used, then the proof is straightforward because the subset relation on the premise still holds. If (R-Eff2) is used, by inversion on (R-Eff2), we have $op \leq_l \varepsilon'$ and $\varepsilon' \leq_{l'} \varepsilon$. By IH we have $op \leq_l \varepsilon' \setminus op'$. By lemma \ref{lemma-minus} we have $\varepsilon'  \setminus op' \leq_{l'} \varepsilon \setminus op'$. Then the result follows by (R-Eff2)
\end{proof}
\end{lemma}

\begin{lemma} (Preservation) \\
If $\Gamma \vdash c_i : \{\varepsilon\} \tau$ and $c_i \longrightarrow c_i'$, then $\Gamma \vdash c_i' : \{\varepsilon\}\tau$

\begin{proof} (Sketch)
By induction on the derivation that $c_i \longrightarrow c_i'$. We proceed by the cases on the last step of the derivation.

\begin{enumerate}
\item E-Ret: By inversion, $\Gamma \vdash e_i: \tau$. By preservation of expressions and IH, we have  $\Gamma \vdash e_i': \tau$. Then we can use E-Ret to derive $\Gamma  \vdash c_i' : \{\varepsilon\} \tau$
\item E-Op: Follow immediately from inversion and IH
\item E-EmbedOp1: Follow immediately from inversion and IH
\item E-EmbedOp2:  
$$\infer[\textsc{(E-EmbedOp2)}]
{[op_j]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow [op_j]^{\varepsilon''}_l(v_i; y_i.c_i) }
{\overline{\Delta_i}(\varepsilon) = \varepsilon''} \quad $$
We have the typing rule as follows:
$$\infer[\textsc{(T-EmbedOp)}]
  {\Gamma\vdash [op]^\varepsilon_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau & \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon') & \Gamma \vdash op \leq_{li} \varepsilon}  $$
  Since $\overline{\Delta_i}(\varepsilon'') = \varepsilon''$ and $\varepsilon'' = \overline{\Delta_i}(\varepsilon)$, we have $\overline{\Delta_i}(\varepsilon'')  \subseteq \overline{\Delta_i}(\varepsilon')$. Then we can use T-EmbedOp to derive $\Gamma\vdash [op]^{\varepsilon''}_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau $
\item E-EmbedOp3:
  We have the typing rule as follows:
$$\infer[\textsc{(T-EmbedOp)}]
  {\Gamma\vdash [op]^\varepsilon_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau & \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon') & \Gamma \vdash op \leq_{li} \varepsilon}  $$
  By E-EmbedOp3, $op \in \overline{\Delta_i}(\varepsilon)$. So $op \in \overline{\Delta_i}(\varepsilon')$. 
By inversion on the typing rule, we have $\Gamma, y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau$. By lemma \ref{lemma-exact}, we have $\Gamma, y_i:\tau_B\vdash c_i: \{\overline{\Delta_i}(\varepsilon')\}\tau$. Then we can use T-Op to derive the designed result $\Gamma \vdash op(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau $

\item E-EmbedOp4:
We have the typing rule as follows:
$$\infer[\textsc{(T-EmbedOp)}]
  {\Gamma\vdash [op]^\varepsilon_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau & \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon') & \Gamma \vdash op \leq_{li} \varepsilon}  $$
By lemma \ref{lemma-relation}, we have $op \leq_{li} \varepsilon \setminus op'$. By inversion on the typing rule, we have $\Gamma, y_i:\tau_B \vdash c_i:\{\varepsilon'\}\tau$ and $\varepsilon \subseteq \overline{\Delta_i}(\varepsilon')$.  So $\varepsilon \setminus op' \subseteq \overline{\Delta_i}(\varepsilon')$. By lemma \ref{lemma-exact}, we have $\Gamma, y_i:\tau_B \vdash c_i:\{\overline{\Delta_i}(\varepsilon')\}\tau$. Then we can apply T-EmbedOp again to derive $\Gamma\vdash [op]^{\varepsilon \setminus op'}_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau $
  
\item E-App1: Follows immediately by T-App
\item E-App2: Follows immediately by T-App
\item E-App3: By inversion of T-App, we $\Gamma \vdash (\lambda x_i: \tau.\ c_i) : \tau \rightarrow \sigma$, $\Gamma \vdash v_i : \tau$. By inversion of T-Lam, $\Gamma, x_i:\tau \vdash c_i : \sigma$. By substitution lemma, we have $\Gamma \vdash \{v_i/x_i\}c_i : \sigma$.

\item E-Seq1:  Follows immediately by T-Seq and IH.
\item E-Seq2: By inversion on T-Seq, we have $\Gamma \vdash \m{return} v_i : \{\varepsilon\}\tau$ and $\Gamma, x_i:  \tau \vdash c_i': \{\varepsilon\}\tau'$. By inversion on T-Ret, we have $\Gamma \vdash v_i: \tau$. Then by substitution lemma we have $\Gamma \vdash \{v_i/x\}c_i' : \{\varepsilon\}\tau'$.
\item E-Seq3: 
$$
\infer[\textsc{(E-Seq3)}]
  {\texttt{do}\ x \leftarrow op_i(v_i; y_i.c_i) \texttt{in}\ c_i' \longrightarrow op_i(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i')}
  {} $$
  By inversion of T-Seq, we have $\Gamma \vdash op_i(v_i; y_i.c_i) : \{\varepsilon\}\tau$  and $\Gamma , x:\tau \vdash c_i' : \{\varepsilon\}\tau'$. By inversion on T-OP, we have $\Gamma, y_i: \tau_B \vdash c_i: \{\varepsilon\}\tau$ and $op \in \varepsilon$ and $\Gamma \vdash v_i : \tau_A$.  Then by T-Seq, we have $\Gamma, y_i : \tau_B \vdash \m{do} x \leftarrow c_i \m{in} c_i' : \{\varepsilon\}\tau'$. Then we can use T-Op to derive $\Gamma \vdash op_i(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i') : \{\varepsilon\}\tau'$.

\item E-Seq4
$$
\infer[\textsc{(E-Seq4)}]
  {\texttt{do}\ x \leftarrow [op_j]^\varepsilon_l(v_i; y_i.c_i) \texttt{in}\ c_i' \longrightarrow [op_j]^\varepsilon_l(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i')}
  {\Delta_i(\varepsilon) = \varepsilon & op \not \in \varepsilon} $$
$$
\infer[\textsc{(T-seq)}]
  {\Gamma\vdash \m{do} x_i \leftarrow c_i \m{in} c_i' : \{\varepsilon'\}\tau' }
  {\Gamma \vdash c_i : \{\varepsilon'\}\tau & \Gamma, x_i:\tau \vdash c_i': \{\varepsilon'\}\tau'}  $$
By inversion on T-Seq, we have $\Gamma \vdash [op_j]^\varepsilon_l(v_i; y_i.c_i): \{\varepsilon'\}\tau$ and $\Gamma, x:\tau \vdash c_i' : \{\varepsilon'\} \tau'$. Then by inversion on T-EmbedOp, we have $\Gamma, y_i:\tau_B \vdash c_i: \{\varepsilon'\}\tau$, $\overline{\Delta_i}(\varepsilon) \subseteq \varepsilon'$.
Then by T-Seq, we have $\Gamma, y_i:\tau_B \vdash \m{do} x \leftarrow c_i \m{in} c_i' : \{\varepsilon'\}\tau'$. Then by T-EmbedOp, we have $\Gamma \vdash [op]^\varepsilon_l(v_i; y_i.  \m{do} x \leftarrow c_i \m{in} c_i' ): \{\varepsilon'\}\tau'$

\item E-Handle1: Follows immediately by inversion on T-Handle and IH
\item E-Handle2: By T-Handle, we have $\Gamma \vdash \m{with} h_i \m{handle} \m{return} v_i :  \{\varepsilon'\}\tau_B$. By inversion on T-Handle, we have $\Gamma, x_i:\tau_A \vdash c_i' : \{\varepsilon\}\tau_B$, and $\Gamma \vdash \m{return} v_i : \{\varepsilon\} \tau_A$. By inversion on T-Ret, we have $\Gamma \vdash v_i : \tau_A$. Then by substitution lemma, we have $\Gamma \vdash \{v_i/x_i\}c_i' : \{\varepsilon'\}\tau_B$. 

\item E-Handle3
$$
\infer[\textsc{(E-Handle3)}]
  {\m{with} h_i \m{handle} op(v_; y_i.c_i) \longrightarrow \{v_i/x_i\} \{(\lambda y_i: \tau_i'.
   \m{with} h_i\m{handle} c_i) / k\}c_i' }
  {op(x_i; k) \mapsto c_i' \in h_i & \Sigma(op) = \tau_i \rightarrow \tau_i'} 
$$
By T-Handle, we have $\Gamma \vdash \m{with} h_i \m{handle} op(v;y_i.c_i) :  \{\varepsilon'\}\tau_B$. By inversion on T-Handle, we have $\Gamma, x_i:\tau_i, k: \tau_i' \rightarrow \{\varepsilon'\}\tau_B \vdash c_i' : \{\varepsilon'\} \tau_B$, and $\Gamma \vdash op(v; y_i.c_i) : \{\varepsilon\} \tau_A$. By inversion on T-Op, we have $\Gamma \vdash v_i : \tau_i$ and $\Gamma, y_i: \tau_i' \vdash c_i: \{\varepsilon\}\tau_A$. By T-Handle, we have $\Gamma, y_i: \tau_i' \vdash \m{with} h_i \m{handle} c_i : \{\varepsilon'\}\tau_B$. Then by T-Lam, we have $\Gamma \vdash \lambda y_i:\tau_i'.\ \m{with} h_i \m{handle} c_i : \tau_i' \rightarrow  \{\varepsilon'\}\tau_B$. Then, by substitution lemma, we have $\Gamma \vdash \{v_i/x_i\} \{(\lambda y_i: \tau_i'.
   \m{with} h_i\m{handle} c_i) / k\}c_i' : \{\varepsilon'\}\tau_B$.
   
\item E-Handle4:
$$
\infer[\textsc{(E-Handle4)}]
  {\m{with} h_i \m{handle} [op]^\varepsilon_l(v_i, y_i.c_i) \longrightarrow [op]^\varepsilon_l(v_i; y_i. \m{with} h_i \m{handle} c_i))}
  {\Delta_i(\varepsilon) = \varepsilon & op \not \in \varepsilon} 
$$

$$
\infer[\textsc{(T-handle)}]
  {\Gamma\vdash \m{with} h_i \m{handle} c_i: \{\varepsilon'\} \tau_B}
  {\begin{gathered}
  h_i = \{\m{return} x \mapsto c^r, op^1(x;k) \mapsto c^1, \dots, op^n(x;k) \mapsto c^n \}\\
  \Gamma, x: \tau_A \vdash c^r : \{\varepsilon'\}\tau_B \quad \\
  \left\{ \Sigma(op^i) = \tau_i \rightarrow \tau_i'  \quad \Gamma, x:\tau_i, k:\tau_i' \rightarrow \{\varepsilon'\}\tau_B \vdash c^i: \{\varepsilon'\}\tau_B    \right\}_{1 \leq i \leq n} \\
  \Gamma \vdash c_i : \{\varepsilon''\}\tau_A \quad \varepsilon'' \setminus \{op^i\}_{1 \leq i \leq n} \subseteq \varepsilon'
  \end{gathered}}
$$
By T-Handle, we have $\Gamma \vdash \m{with} h_i \m{handle} [op]^\varepsilon_l(v;y_i.c_i) :  \{\varepsilon'\}\tau_B$. By inversion on T-Handle, we have $\Gamma \vdash [op]^\varepsilon_l(v;y_i.c_i): \{\varepsilon''\}\tau_A$ and $\varepsilon'' \setminus \{op^i\} \subseteq \varepsilon'$. By inversion on T-EmbedOp, we have $\Gamma \vdash v_i: \tau_i$, $\Gamma, y_i:\tau_i' \vdash c_i : \{\varepsilon''\}\tau_A$ and $\varepsilon \subseteq \varepsilon''$. Since $\varepsilon$ doesn't contain any concrete operation, we have $\varepsilon \subseteq  \varepsilon'' \setminus \{op^i\} \subseteq \varepsilon' $. Then by T-Handle, we have $\Gamma, y_i: \tau_i' \vdash \m{with} h_i \m{handle} c_i : \{\varepsilon'\}\tau_B$. Then, we use T-EmbedOp to derive $\Gamma \vdash [op]^\varepsilon_l(v_i; y_i. \m{with} h_i \m{handle} c_i) : \{\varepsilon'\}\tau_B$


\item E-Embed1: Follows immediately from Inversion and IH
\item E-Embed2: By typing rule, we have $\Gamma \vdash [\m{return} v_j]^{\{\varepsilon\}\tau}_l :\{\varepsilon\}\tau$. By inversion on the typing rule, we have $\Gamma \vdash \m{return} v_j : \{\varepsilon'\}\tau'$ such that $\{\varepsilon\}\tau' \leq_{li} \{\varepsilon\}\tau$. By inversion on R-Sigma, we have $\tau' \leq_{li} \tau$. Then by T-EmbedExp, we have $\Gamma \vdash [v_j]^\tau_l : \tau$. Then by T-Ret, we have $\Gamma \vdash \m{return}  [v_j]^\tau_l : \{\varepsilon\}\tau$. $\Gamma \vdash [\m{return} v_j]^{\{\varepsilon\}\tau}_l :\{\varepsilon\}\tau$

\item E-Embed3: 
$$
\infer[\textsc{(E-Embed3)}]
{[op(v_j; y_j.c_j)]^{\{\varepsilon\}\tau}_l \longrightarrow [op]^\varepsilon_l([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_l)}
{ \Sigma(op) = \tau_A \rightarrow \tau_B} 
$$
By typing rule, we have $\Gamma \vdash op(v_j; y_j.c_j) : \{\varepsilon'\}\tau'$, where $\{\varepsilon'\}\tau' \leq_{li} \{\varepsilon\}\tau$. By inversion on T-Op, we have $\Gamma \vdash v_j : \tau_A$, and $\Gamma, y_j : \tau_B \vdash c_j: \{\varepsilon'\}\tau'$. Then, by T-EmbedExp, we have $\Gamma \vdash [v_j]^{\tau_A}_j : \tau_A$. By substitution lemma, we have $\Gamma, y_i: \tau_B \vdash \{[y_i]^{\tau_B}_i/y_j\}c_j : \{\varepsilon'\}\tau'$. By T-Embed, we have $\Gamma, y_i: \tau_B \vdash \{[y_i]^{\tau_B}_i/y_j\}[c_j]^{\{\varepsilon\}\tau}_l : \{\varepsilon\}\tau$. Then we can use T-EmbedOp to derive $\Gamma \vdash [op]^\varepsilon_l([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_l): \{\varepsilon\}\tau$. 

\item E-Embed4:
$$
\infer[\textsc{(E-Embed4)}]
{[[op_k]^{\varepsilon'}_{l'}(v_j; y_j.c_j)]^{\{\varepsilon\}\tau}_l \longrightarrow [op_k]^\varepsilon_{l'jl}([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_l)}
{ \Sigma(op_k) = \tau_A \rightarrow \tau_B& \Delta_j(\varepsilon') = \varepsilon' & op \not \in \varepsilon'} 
$$
By typing rule, we have $\Gamma \vdash [op_K]^{\varepsilon'}_{l'}(v_j; y_j.c_j) : \{\varepsilon''\}\tau''$, where $\{\varepsilon''\}\tau'' \leq_{li} \{\varepsilon\}\tau$. By inversion on T-EmbedOp, we have $\Gamma \vdash v_j: \tau_A$ and $\Gamma, y_j : \tau_B \vdash c_j: \{\varepsilon''\}\tau''$. Then, by T-EmbedExp, we have $\Gamma \vdash [v_j]^{\tau_A}_j : \tau_A$.
By substitution lemma, we have $\Gamma, y_i: \tau_B \vdash \{[y_i]^{\tau_B}_i/y_j\}c_j : \{\varepsilon''\}\tau''$. By T-Embed, we have $\Gamma, y_i: \tau_B \vdash \{[y_i]^{\tau_B}_i/y_j\}[c_j]^{\{\varepsilon\}\tau}_l : \{\varepsilon\}\tau$. Then we use T-EmbedOp to derive $\Gamma \vdash [op_k]^\varepsilon_{l'jl}([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_l) : \{\varepsilon\}\tau$.
\end{enumerate}
\end{proof}
\end{lemma}

\begin{lemma} (Progress) \\
If $\varnothing \vdash c_i : \{\varepsilon\} \tau$ then either
\begin{enumerate}
\item  $c_i \longrightarrow c_i'$ 
\item  $c_i = \m{return} v_i$
\item $c_i = op(v_i; y_i.c_i')$
\item $c_i = [op]^\varepsilon_l(v_i; y_i.c_i')$
 \end{enumerate}
\end{lemma}







\begin{definition}
A i-computation $c$ is \underline{oblivious} to effect label $f$ if $f \not\in Dom(\delta_i)$, and for all subexpression $[e]^\tau_j$ and subcomputation $[c]^\sigma_j$, $f \not\in Dom(\delta_j)$
\end{definition}


\begin{theorem} 

Let $c_1$ and $c_2$ be computations that are oblivious to the effect $f$.  If $c_1 \approx c_2$, $c_1 \rightarrow c_1'$, $c_2 \rightarrow c_2'$, then $c_1' \approx c_2'$. Furthermore,  If $e_1, e_2$ oblivious to f, $e_1 \approx e_2$, $e_1 \rightarrow e_1'$, $e_2 \rightarrow e_2'$, then $e_1' \approx e_2'$

The relation $\approx$ is defined as follows:
\begin{figure}[H]
\flushleft
\footnotesize{

$\fbox{$e \approx e$}$
\[
\begin{array}{c}
\infer[\textsc{(R-Var)}]{x \approx x}
{} \qquad \infer[\textsc{(R-Unit)}]{() \approx ()}{} \\[3ex]
\infer[\textsc{(R-Lam)}]{\lambda x:\tau.\ c \approx \lambda x:\tau.\ c'}{c \approx c'} \qquad
\infer[\textsc{(R-EmbedExp)}]{[e]^\tau_l \approx [e']^\tau_l}{e \approx e'}
\end{array}
\]


$\fbox{$c \approx c$}$
\[
\begin{array}{c}
\infer[\textsc{(R-Ret)}]
  {\m{return} e \approx \m{return} e'}
  {e \approx e'}  
  \quad 
\infer[\textsc{(R-op)}]
  {op''(e; y.c) \approx op''(e'; y.c')}
  {e \approx e' & c \approx c'}
  \\[3ex]
\infer[\textsc{(R-Seq)}]
  {\m{do} x \leftarrow c \m{in} d \approx \m{do} x \leftarrow c' \m{in} d'}
  {c \approx c' & d  \approx d'} \quad
\infer[\textsc{(R-App)}]
  {e_1\ e_2 \approx e_1'\ e_2'}
  {e_1 \approx e_1' & e_2 \approx e_2'} \\[3ex]
\infer[\textsc{(R-Handle)}]
  {\m{with} h \m{handle} c \approx \m{with} h' \m{handle} c'}
  {h \approx h' & c \approx c'} \quad 
\infer[\textsc{(R-Embed)}]
  {[c_j]^\sigma_l \approx [c_j']^\sigma_l}
  {c_j \approx c_j'} \\[3ex]

\infer[\textsc{(R-Embedop1)}]
  {[op'']^\varepsilon_l(e; y.c) \approx [op'']^\varepsilon_l(e'; y.c')}
  {e \approx e' & c \approx c'}
  \quad
\infer[\textsc{(R-Embedop2)}]
  {[op]^\varepsilon_l(e; y.c) \approx [op']^\varepsilon_l(e'; y.c')}
  {e \approx e' & c \approx c' & \exists i \in l, \delta_i(f) = op, op'} \\[3ex]
\end{array}
\]

$\fbox{$h \approx h$}$
\[
\begin{array}{c}
\infer[\textsc{(R-Handler)}]{\begin{gathered} \{\m{return} x \mapsto c_r, op_1(x_1, k_1) \mapsto c_1, \dots, op_n(x_n, k_n) \mapsto c_n\} \approx \\\{\m{return} x \mapsto c_r', op_1(x_1, k_1) \mapsto c_1', \dots, op_n(x_n, k_n) \mapsto c_n'\}  
 \end{gathered} }{ c_r \approx c_r' & c_1 \approx c_1', \dots c_n \approx c_n'} 
\end{array}
\]


}
\caption{Definition of $\approx_{op, op'}$}
\end{figure}




\begin{proof}(Sketch) By induction on derivation of $c_1 \approx c_2$ and $e_1 \approx e_2$
\begin{enumerate}
\item R-Ret:
  The only reduction rule that applies is E-Ret, so we have $e_1 \longrightarrow e_1'$ and $e_2 \longrightarrow e_2'$. By IH, we have $e_1' \approx e_2'$. Then the result follows by R-Ret
\item R-Op: The only reduction rule that applies is E-Op. The result is immediate by IH.
\item R-Seq: If the reduction rule is E-Seq1, then result is immediate by IH. 

If the reduction rule is E-Seq2. Then we have $c_1 = \m{do} x \leftarrow \m{return} v_1 \m{in} d_1$, $c_2 = \m{do} x \leftarrow \m{return} v_2 \m{in} d_2$. By inversion, we have $v_1 \approx v_2$ and $d_1 \approx d_2$. So we have $\{v_1/x\}d_1 \approx \{v_2/x\}d_2$.

If the reduction rule is E-Seq3, then $c_1 = \m{do} x \leftarrow op(v_1; y. k_1) \m{in} d_1$, $c_2= \m{do} x \leftarrow op(v_2; y. k_2) \m{in} d_2$. By inversion, we have $k_1 \approx k_2$ and $d_1 \approx d_2$. So $\m{do} x \leftarrow k_1 \m{in} d_1 \approx \m{do} x \leftarrow k_2 \m{in} d_2$. So $op(v_1; y. \m{do} x \leftarrow k_1 \m{in} d_1) \approx op(v_2; y. \m{do} x \leftarrow k_2 \m{in} d_2)$. The proof is similar for rule E-Seq4.

\item R-App: The cases for reduction rules E-App1 and E-App2 follows by IH. If reduction rule is E-App3. Then $c_1 = (\lambda x:\tau.\ d_1)\ v_1$ and $c_2 = (\lambda x:\tau.\ d_2)\ v_2$. By inversion we have $d_1 \approx d_2$ and $v_1 \approx v_2$. So we have $\{v_1/x\}d_1 \approx \{v_2/x\}d_2$.

\item R-Handle: If reduction rule is E-Handle1, then result follows by IH. 

If the reduction rule is E-Handle2. Then $c_1 = \m{with} h_1 \m{handle} \m{return} v_1$ and $c_2 = \m{with} h_2 \m{handle} \m{return} v_2$. By inversion we have $h_1 \approx h_2$, $v_1 \approx v_2$.  Let $\m{return} c_{r1} \in h_1$ and $\m{return} c_{r2} \in h_2$. By inversion we have $c_{r1} \approx c_{r2}$. So $\{v_1/x\}c_{r1} \approx \{v_2/x\}c_{r2}$.

If the reduction rule is E-Handle3. Then $c_1 = \m{with} h_1 \m{handle} op(v_1; y. k_1)$ and $c_2 = \m{with} h_2 \m{handle} op(v_2; y.k_2) $. By inversion we have $v_1 \approx v_2$, $k_1 \approx k_2$ and $h_1 \approx h_2$. Then by equivalents rules we derive $c_1' \approx c_2'$. The case for E-Handle4 is similar.

\item R-Embed: If reduction is E-Embed1,  result is immediate by IH. If reduction rule is E-Embed2, then $c_1 = [\m{return} v_1]^{\{\varepsilon\}\tau}_l$ and $c_2 = [\m{return} v_2]^{\{\varepsilon\}\tau}_l$. It is easy to see $[v_1]^\tau \approx [v_2]^\tau$. So the result holds.

If the reduction rule is E-Embed3, Then $c_1 = [op(v_1; y. k_1)]{\{\varepsilon\}\tau}_l$ and $c_2 = [op(v_2; y. k_2)]^{\{\varepsilon\}\tau}_l$. By inversion we have $v_1 \approx v_1$, $k_1 \approx k_2$. Then by equivalent rules we have $c_1' \approx c_2'$. Same arguments apply for E-Embed4.

\item R-EmbedOp1: If reduction rule is E-EmbedOp1, then result follows by IH. If reduction rules is E-EmbedOp2 or E-EmbedOp3, reduction does not affect terms except effect annotation, so the equivalence relation still hods after reduction.

\item R-EmbedOp2: Reduction rules E-EmbedOp1 and E-EmbedOp2 are similar to the previous case. If the reduction rule is E-EmbedOp3, then by R-EmbedOp2, the operations $op$ and $op'$ are exported as effect $f$ by some agent, and since current agent is oblivious to $f$, this case is impossible.

\end{enumerate}


\end{proof}


\end{theorem}

\pagebreak
\section{Abstraction Problem I}
\begin{lstlisting}


op : 1 -> 1
  
module b: B
  f = op
  def m() : {f} Unit
    op ()
  def handler(c: 1 -> {f} 1) : {} Int = 
    handle c () with
    |  op () -> 1
    | return _ -> 0

// Example program
b.handler(
  () => handle b.m() with
          | op -> resume ()
          | return _ -> ()
 )

// Translation of Example Program
[$\lambda$c: 1 -> {f} 1. 
  handle c() with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{(1 \rightarrow \{f\} 1) \rightarrow \{\} int}_b$
($\lambda$_:1. 
  handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
  | op(x, k) -> k ()
  | return _ -> return ())
  
\\steps--->
 ($\lambda$c: 1 -> {f} 1. 
  [handle [c]$^{1 \rightarrow \{f\} 1}_a$  () with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$)
($\lambda$_:1. 
  handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
  | op(x, k) -> k ()
  | return _ -> return ())
  
\\steps--->
  [handle 
     [$\lambda$_:1. 
      handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{1 \rightarrow \{f\} 1}_a$  () 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
 
 \\steps--->
[handle 
     $\lambda$_:1. 
      [handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{\{f\} 1}_a$  () 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
  
\\steps--->
[handle 
      [handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{\{f\} 1}_a$ 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
  

\\steps--->
[handle 
      [handle $\lambda$_:1. [op()]$^{\{f\} 1}_b$ () with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{\{f\} 1}_a$ 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
  
\\steps--->
[handle 
      [handle [op()]$^{\{f\} 1}_b$ with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{\{f\} 1}_a$ 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
  
\\steps--->
[handle 
      [handle op$^f_b$((), y.return y) with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{\{f\} 1}_a$ 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
  
\\steps--->
[handle 
      [op$^f_b$((), y. handle return y with
                       | op(x, k) -> k ()
                       | return _ -> return () 
          )]$^{\{f\} 1}_a$ 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
  
\\steps--->
[handle 
      op$^f_{ba}$((), y. [handle return y with
                       | op(x, k) -> k ()
                       | return _ -> return ()]$^{\{f\} 1}_a$ 
          )
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
  
\\steps--->
[handle 
      op((), y. [handle return y with
                       | op(x, k) -> k ()
                       | return _ -> return ()]$^{\{f\} 1}_a$ 
          )
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
  
\end{lstlisting}


\section{Existential Type for Algebraic Effect}
\label{sec-exist}
In the previous sections, we have introduced the core calculus of abstract algebraic effects via embeddings. However it is  impractical for requiring programmers to explicitly annotate each program components with embeddings. So we present a top level language where the annotations are implicitly added during evaluation of the program.  

According to \citet{mitchell88}, there is a correspondence between abstraction data types and existential types. Existential types are often used as a foundation for expressing type abstraction in module systems. The  calculus introduced in this section contains a form of existential type that provide abstraction mechanisms for algebraic effects. The this form of expression of existential type would generate new agents during evaluation of program and automatically separate program components with different knowledge, so programmers would not need to explicitly work with agents and embeddings.

\subsection{Syntax}
\begin{figure}
\label{fig-syntax}
\begin{align*}
&(agents) &i, j &::= \{1 \dots n\}\\
&(lists) & l &::= i \mid il\\
&(expression\ types) &\tau &::= 1 \mid \tau \rightarrow \sigma \mid \exists f.\ \tau \\
&(computation\ types) &\sigma &::= \{\varepsilon\}\tau\\
&(effect\ types) &\varepsilon &::= \cdot \mid f, \varepsilon \mid op, \varepsilon\\
&(i\ values) &{v_i} &::= ()_i \mid \lambda x_i:\tau.\ c_i \mid \m{pack} (\varepsilon, v) \m{as} \exists f.\ \tau\\
&(i\ expression) &e_i &::= x_i \mid v_i \mid [e_j]^\tau_l \mid \m{pack} (\varepsilon, e) \m{as} \exists f.\ \tau  \mid \m{open} e \m{as} (f, x) \m{in} e'\\
&(i\ computation) &c_i &::= \texttt{return}\ e_i \mid op(e_i, y.c_i) \mid \texttt{do}\ x \leftarrow c_i\ \texttt{in}\ c_i' \mid e_i\ e_i' \mid \texttt{with}\ h_i\ \texttt{handle}\ c_i\\
 &\ &\mid\ &[c_j]^\sigma_l \mid [op]^\varepsilon_l (e_i, y_i.c_i)\\
&(i\ handler) &h_i &::= \texttt{handler}\ \{\texttt{return}\ x_i \mapsto c^r_i, op^1(x_i^1, k^1) \mapsto c_i^1 \dots  op^n(x_i^n, k^n) \mapsto c_i^n\}  
\end{align*}
\caption{Syntax for Existential Effects}
\end{figure}

Most of the syntax remains the same for our new language. The existential type $\exists f.\ \tau$ is added as an expression type. The intuition of the type is that the value of this type isa value of type $\{\varepsilon/f\}\tau$ for some effect type $\varepsilon$. 

There  are two new forms of expressions: The introduction form of the existential type, $\m{pack} (\varepsilon, e) \m{as} \exists f.\ tau$ and the elimination form, $\m{open} e \m{as} (f, x) \m{in} e'$. The $\m{pack}$ expression creates existential package that contains an effect type $\varepsilon$ and an expression $e$.  The $\m{open}$ expression opens up an existential package and substitute the expression in the package for the variable $x$.

We only introduce one form of value: the existential package $\m{pack} (\varepsilon, v) \m{as} \exists f.\ \tau$ 


\subsection{Dynamic Semantics}
\begin{figure}[t]
\footnotesize{
\noindent$\fbox{$\langle \{\Delta\}, e \rangle \mapsto \langle \{\Delta\}, e \rangle$}$
\[
\begin{array}{c}

\infer[\textsc{(E-pack)}]
  {\langle \{\Delta\}, \m{pack} (\varepsilon, e) \m{as} \exists f.\ \tau  \rangle \mapsto \langle \{\Delta'\} , \m{pack} (\varepsilon, e') \m{as} \exists f.\ \tau  \rangle}
  {\langle \{\Delta\}, e \rangle \mapsto \langle \{\Delta'\}, e' \rangle} \\[3ex]
  
\infer[\textsc{(E-open)}]
   {\langle \{\Delta\},  \m{open} (\m{pack} (\varepsilon, e) \m{as} \exists f.\ \tau) \m{as} (f, x) \m{in} e'  \rangle \mapsto \langle \{\Delta'\}, \{[e]_j^\tau / x\}e' \rangle}
  {f \m{fresh} & j \m{fresh} & \Delta'_j = \Delta_i[f \mapsto \varepsilon] & \forall \Delta_k \in \{\Delta\}, \Delta_k' = \Delta_k[f \mapsto f]} \\[3ex]
  
\infer[\textsc{(E-EmbedPack)}]
  {\langle \{\Delta\}, [\m{pack} (\varepsilon, v) \m{as} \exists f.\ \tau]^{\exists f.\ \tau'}_j \rangle \mapsto \langle \{\Delta\}, \m{pack} (\varepsilon, [v]^{\{\varepsilon/f\}\tau'}_j) \m{as} \exists f.\ \tau' \rangle}
  {}
  
\end{array}
\]
\label{static-exist}
\caption{Additional Dynamic Semantics for Existential Type}
}
\end{figure}

The semantics for existential type $\exists f.\ \tau$  hides the definition of the effect label $f$ from the client of the value of this type. We leverage the our previous design of multi-agent calculus to achieve information hiding. However, the previous design assumes that the type information for each agents are predetermined and does not change during evaluation. Since existential types generate new abstraction boundaries, we need a different semantics that allow agents to be created during evaluation. Therefore, we modify the reduction rule to evaluate a pair that contains both the expression to evaluate and a context of type information. The idea to keep track of type information while evaluating terms was used by \citet{grossman00} to encode parametric polymorphism in their system.

We introduce the notation $\{\Delta\}$ to express a list of type maps for all agents in the context $\{\Delta_1, \dots \Delta_n\}$. The type information of each agents can change, and new agents can be generated, the evaluation judgment becomes $\langle \{\Delta\}, e \rangle \mapsto \langle \{\Delta\}, e \rangle$. 

(E-Pack) shows the congruence rule for reduction of a pack expression. (E-Open) opens an existential package: This rule requires $f$ to be a fresh label, which achievable by doing alpha conversion in $e'$. $j$ is a fresh agent. A new type map for agent $j$ extends the type map for $i$ by mapping $f$ to $\varepsilon$. Every existing type map in $\{\Delta\}$ is extended by mapping $f$ to itself. Finally, $[e]^\tau_j$ is substituted for $x$ in $e'$.

(E-EmbedPack) shows how the embedding interacts with existential packages. The existential package is lifted out of the embedding, and the value $v$ becomes an embedded j-value with type annotation $\{\varepsilon/f\}\tau'$.

The reduction rules for remaining terms are not changed by the introduction of $\{\Delta\}$ and are therefore not shown. 

\subsection{Static Semantics}
\begin{figure}[t]
\footnotesize{
\noindent$\fbox{$\{\Delta\} \mid \Gamma  \vdash e_i : \tau$}$
\[
\begin{array}{c}

\infer[\textsc{(T-pack)}]
  {\{\Delta\}\mid \Gamma \vdash \m{pack} (\varepsilon, e) \m{as} \exists f.\ \tau : \exists f.\ \tau}
  {\{\Delta\}\mid \Gamma \vdash e : \{\varepsilon / f\} \tau} \\[3ex]
  
\infer[\textsc{(T-open)}]
  {\{\Delta\}\mid \Gamma \vdash \m{open} e \m{as} (f, x) \m{in} e' : \tau'}
  {\{\Delta\}\mid \Gamma \vdash e : \exists f.\ \tau & \forall \Delta_i \in \{\Delta\}, \Delta'_i = \Delta_i[f\mapsto f] & \{\Delta'\}\mid \Gamma, x:\tau \vdash e' : \tau'}

\end{array}
\]
\label{static-exist}
\caption{Additional Static Semantics for Existential Effects}
}
\end{figure}

The typing rules also requires the set of type maps, so the judgment have the form $\{\Delta\} \mid \Gamma \vdash e : \tau$
(T-Pack) assigns the type $\exists f.\ \tau$ to the existential package if the expression $e$ has type $\{\varepsilon/f\}\tau$. The rule (T-Open) assigns the type $\tau'$ to the open expression if $e$ has the existential type $\exists f.\ \tau$ and $e'$ has type $\tau'$ given that the context is extended with variable $x$, and the set of type maps is extended with the effect label $f$. 





\subsection{Type Relation}

\subsection{Type Safety}
\begin{lemma} (Preservation)\\
If $\{\Delta\} \mid \Gamma \vdash e : \tau$ and $\langle \{\Delta\}, e\rangle \mapsto \langle \{\Delta'\}, e'\rangle$, then $\{\Delta'\} \mid \Gamma \vdash e' : \tau$
\begin{proof}
By rule induction on the dynamic semantics of expressions. 
\begin{enumerate}
\item (E-Congruence): By inversion on typing judgement and applying IH.
\item (E-Unit): By directly applying (T-Unit)
\item (E-Lambda): 
$$\infer[\textsc{(E-Lambda)}]
  {[\lambda x_j : \tau'.\ c_j]^{\tau \rightarrow \sigma}_{j} \longrightarrow \lambda x_i : \tau.\ [\{[x_i]^{\tau'}_{i}/x_j\}c_j]^\sigma_{jl}}
  {}$$
By inversion on (T-EmbedExp), we have $\{\Delta\} \mid \Gamma \vdash  [\lambda x_j : \tau'.\ c_j]^{\tau \rightarrow \sigma}_{j}: \tau \rightarrow \sigma$, and $\{\Delta\} \mid \Gamma \vdash \lambda x_j : \tau'.\ c_j : \tau' \rightarrow \sigma'$, where $\{\Delta\} \mid \Gamma \vdash \tau' \rightarrow \sigma' \leq_j \tau \rightarrow \sigma$. By inversion on (T-Lam), we have $\{\Delta\} \mid \Gamma, x_j : \tau' \vdash c_j : \sigma$. Then by substitution lemma, we have $\{\Delta\} \mid \Gamma, x_i : \tau  \vdash \{[x_i]^{\tau'}_i/x_j\}c_j : \sigma'$. By (T-Embed), 
$\{\Delta\} \mid \Gamma, x_i : \tau  \vdash [\{[x_i]^{\tau'}_i/x_j\}c_j : \sigma']^{\sigma}_j : \sigma$. Then the result follows by (T-Lam).

\item (E-Pack): By inversion and IH.
\item (E-Open): By inversion on (T-Pack), we have $\{\Delta\} \mid \Gamma \vdash e : \{\varepsilon /f\} \tau$. Then by (T-EmbedExp), we have $\{\Delta'\} \mid \Gamma \vdash [e]^\tau_j : \tau$. By inversion on (T-Open), $\{\Delta\} \mid \Gamma, x : \tau \vdash e' : \tau'$. Since $j$ is fresh, $e'$ doesn't contain any $j$ term, so the type information from agent $j$ doesn't affect the typing of $e'$. Therefore, $\{\Delta'\} \mid \Gamma, x : \tau \vdash e' : \tau'$. Finally, by substitution lemma, we have $\{\Delta'\} \mid \Gamma \vdash \{[e]^\tau_j / x \}e' : \tau'$.

\item (E-EmbedPack): By inversion on (T-EmbedExp), we have $\{\Delta\} \mid \Gamma \vdash \m{pack} (\varepsilon, v) \m{as} \exists f.\ \tau : \exists f.\ \tau$, and $\{\Delta\} \mid \Gamma \vdash \exists f.\ \tau \leq_j \exists f.\ \tau'$. By type relation, we have $\tau \leq_j \tau'$. Then by inversion on (T-Pack), we have $\{\Delta\} \mid \Gamma \vdash v :\{\varepsilon / f\}\tau$. Then by T-EmbedExp, we have $\{\Delta\}\mid\Gamma \vdash [v]^{\{\varepsilon / f\}\tau'}_j : \{\varepsilon / f\}\tau'$. Then by (T-Pack), we get $\{\Delta\}\mid\Gamma \vdash \m{pack} (\varepsilon, [v]^{\{\varepsilon / f\}\tau'}_j) \m{as} \exists f.\ \tau' :\exists f.\ \tau'$


\end{enumerate}
\end{proof}

\end{lemma}

\begin{lemma} (Progress)\\
If $\{\Delta\} \mid \Gamma \vdash e : \tau$ then either $e$ is a value or there exists $e'$ and $\{\Delta'\}$ such that $\langle \{\Delta\}, e \rangle \mapsto \langle \{\Delta'\}, e' \rangle$
\end{lemma}





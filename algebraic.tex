% !TEX root = thesis.tex

\chapter{Abstract Algebraic Effects Via Embedding}
\label{chapter-algebraic}

\section{Background and Motivation}
\label{sec-motivation}

Algebraic effects (introduced by \citet{plotkin02}) and handlers (introduced by \citet{plotkin09}) are an approach to computational effects based on a premise that impure behavior arises from a set of operations, and are recently gaining popularity due to their ability to model various form of computational effects such as exceptions, mutable states, async-await, etc.

Modularity is a key concept that separates abstract algebraic effects from the traditional way of using monad to model effects in purely functional programming \cite{schrijvers19}. However, similar to the restrictive strand of work on effects, few works on algebraic effects has investigated the algebraic effect system on a larger scale, where abstraction between program components is important. \\

Abstract algebraic effects are first introduced in \citet{biernacki19}. Similar to abstract types, abstract algebraic effects allow program components to define abstract effect signatures that is opaque to other components in the system. The difference between concrete and abstract effect signatures lies in the ability for program components to handle them. If an effect signature is concrete to a program component, then the operations are accessible the component, and a handler can handles the effect by handling the operations in the signature. On the other hand, if an effect signature is abstract to one program component, then the component should not observe the operations defined in the effect signature, and is therefore unable to handle the effect. As abstraction is an important issue for module systems because it provides a separation of implementation details of functions from the interface, abstraction of algebraic effects provides a similar benefit for modularity because it helps separate the component operations from the effect signature, ensuring that the client can only uses the handler provided by the library to handle the effect.

The following code is a motivating example similar to the example in \cite{biernacki19} that illustrates the challenges of implementing abstract algebraic effects. \li{Nondet} is a globally defined effect signature. Then we define a module \li{m} with type \li{M} with an abstract effect \li{E}, a method \li{mflip}, and a handler method \li{handle}. The effect \li{E} is defined by \li{Nondet}, but is opaque to the outside world of the module, because \li{E} is defined as an abstract effect in the type \li{M}. The method \li{mflip} simply calls the \li{flip} operation, and the \li{handle} method handles the \li{flip} operation by returning \li{true}. 

\begin{lstlisting}[language=scala]  
effect Nondet {
    flip(): Bool  
}

type M
  effect E 
  def mflip() : {this.E} Bool
  def handler(Unit -> {this.E} Bool) : {} Bool
  
module m: M
  effect E = {Nondet}
  def mflip() : {this.E} Unit
    flip()
  def handle(c: Unit -> {this.E} Bool) : {} Bool = 
    handle c() with
    | flip() -> resume true

m.handle(
  () => handle m.mflip() with
          | flip() ->  resume false
 )
\end{lstlisting}

The last segment of the above example shows an client code of module \li{m} that calls the method \li{m.handle} and pass in an expression that encapsulate the call to \li{m.mflip} by another handler that handles the \li{flip} operation. Since the effect of the method \li{m.mflip} is abstract, the inner handler should not handle the operation inside \li{m.mflip}. Instead, the operation should be handled by the outer handler method \li{m.hanlde}.  

As we can see, the abstraction of effect signatures differs from type abstractions, since the erasure of type information would make the abstraction unsound. So we need a language that keep track of the information on effect abstraction during the evaluation of the program. In this work, we incorporate the method of syntactic type abstraction introduced by \citet{grossman00}, who use the notion of principals to track the flow of values with abstract types during the evaluation of a program. 

\section{A Simple Example of an Agent-based Language}
Consider the simple case where we only have two agents, namely the client \li{c}, and the host \li{h}. And the host \li{h} defines an abstract effect \li{E}, exports a method that causes the effect and a method that handles the effect.
\begin{lstlisting}[mathescape=true]
module h = 
  effect E = ...
  val m : 1 -> {E} 1 = ..
  ...
\end{lstlisting}

Now consider client code wants to handle the \li{m} function from h\\
\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape=true]
handle 
  [m ()]$_h^E$
with
  op (x) -> ...
  return x -> ...
\end{lstlisting}
\end{minipage}

Since $m$ function is called in the client code, we use a language construct called embedding to encapsulate the function call. This subscript of the embedding indicates that the code inside the embedding is host code, and the superscript indicates that the effect of the code is \li{E}, which is abstract to the client. So the embedding ensures that the client would not be able to handle the operation inside the function \li{m}, therefore keeping the effect abstraction safe. 

Besides making the client unable to handle an abstract effect, we need to make sure that a host code can "rediscover" the effect exported by itself. The scenario would be exhibited by the following host code. The client code we showed earlier is now embedded into another handler that handles the the effect E. Because the outer-most handler is now in host code, it would be able to handle the effect operation inside the function \li{m}.

\begin{minipage}{\linewidth}
\begin{lstlisting}[mathescape=true]
handle 
  [handle 
    [m ()]$_h^E$
  with
    op (x) -> ...
    return x -> ...]$_c^E$
with
  op (x) -> ...
  return x -> ...
\end{lstlisting}
\end{minipage}




\section{Core Calculus}
\label{sec-core}
\subsection{Syntax}
\begin{figure}
\begin{align*}
&(agents) &i, j &::= \{1 \dots n\}\\
&(lists) & l &::= i \mid il\\
&(value\ types) &\tau &::= unit \mid \tau \rightarrow \sigma\\
&(computation\ types) &\sigma &::= \{\varepsilon\}\tau\\
&(effect\ types) &\varepsilon &::= \cdot \mid f, \varepsilon \mid op, \varepsilon\\
&(i\  values) &{v_i} &::= ()_i \mid \lambda x_i:\tau.\ c_i\\
&(i\ expression) &e_i &::= x_i \mid v_i \mid [e_j]^\tau_j \\
&(i\ computation) &c_i &::= \texttt{return}\ e_i \mid op(e_i, y.c_i) \mid \texttt{do}\ x \leftarrow c_i\ \texttt{in}\ c_i' \mid e_i\ e_i' \mid \texttt{with}\ h_i\ \texttt{handle}\ c_i\\
 &\ &\mid\ &[c_j]^\sigma_j \mid [op]^\varepsilon_l (e_i, y_i.c_i)\\
&(i\ handler) &h_i &::= \texttt{handler}\ \{\texttt{return}\ x_i \mapsto c^r_i, op^1(x_i^1, k^1) \mapsto c_i^1 \dots  op^n(x_i^n, k^n) \mapsto c_i^n\}  
\end{align*}
\caption{Syntax for multi-agent calculus}
\label{fig-core}
\end{figure}

This section describes a variant of the simply typed lambda calculus that maintains a syntactic distinction between agents during evaluation. Figure \ref{fig-core} gives the syntax of our calculus. As our previous discussion, it is crucial to keep track of the effect abstraction information during the evaluation of the program. It is therefore natural to divide the code into agents, and allow each agent to export abstract effect signatures. We assume that there are $n$ agents, and use variables $i, j, k$ to range over the set of agents. 

Every term in this language is assigned to an agent. And terms are split into inert expressions and potentially effectful computations, following an approach called \emph{fine-grain call-by-value}, introduced by \citet{levy03}. We use the notation \emph{i-expression} and \emph{i-computation} to denote expressions and computations in the agent i. We use subscripts to indicate a term is assigned to an agent, however, we will omit the subscript if the agent the term belongs to is not important or obvious in the context.

An \emph{i-value} is an \emph{i-expression} that cannot further reduce. There are two forms of \emph{i-value}: the unit $()$, and the lambda abstraction $\lambda x_i: \tau.\ c_i$. \emph{i-expressions} include variable $x_i$, value $v_i$, and embedded expressions $[e_j]^\tau_j$. \emph{i-computations} are the terms that can potentially cause effects, and consists of return statement $\m{return} e_i$, operation call $op(e_i; y_i.c_i)$, sequencing $\m{do} x_i \leftarrow c_i \m{in} c_i'$, application $e_i\ e_i'$, handling $\m{with} h_i \m{handle} c_i$, embedded computation $[c_j]^\sigma_j$, and embedded operation call $[op]^\varepsilon_l(e_i; y_i.c_i)$. There are few things worth mentioning: 
\begin{enumerate}
\item[] \textbf{Sequencing}: in $\m{do} x \leftarrow c \m{in} c'$, we first evaluate $c$,  bind the return value of $c'$ to x and then evluate $c_2$
\item[] \textbf{Operation Calls}: The call $op(e; y.c)$ passes the parameter $e$ to the operation $op$,  binds the return value of the operation call to $y$, and continue by evaluating the computation $c$. Note that the encompassing handler could potentially change the behavior of the operation.
\item[] \textbf{Embeddings}: the term $[e_j]^\tau_j$ is i-expression that contains an embedded j-expression, with a type $\tau$ exported by $j$. Similarly, $[c_j]^\sigma_j$ is an embedded j-expression with exported type $\sigma$ 
\item[] \textbf{Embedded Operations}: The embedded operation $[op]^\varepsilon_l(e; y.c)$ is a operation call that is annotated with effect $\varepsilon$. $l$ is a list of agents that have contributed to the formation of the annotation. We will describe this in more detail later.
\todo[inline]{Does this appear in source code?}
\end{enumerate}

\todo[inline]{Why have a continuation c rather than just return the value from op?}

Similar to terms, types are also divided into expression types and computation types. There are two forms of expression types $\tau$: the unit type $1$, and the arrow type $\tau \rightarrow \sigma$. As for the computation type $\sigma$, there is only one form: $\{\varepsilon\}\tau$: where $\varepsilon$ is a set of effect that the computation might induce, and $\tau$ is the type of the return value of the computation. 

The effect type $\varepsilon$ represents an unordered set of effects that can be empty $\cdot$. A effect type can be extended by either an effect label $f$, or an operation $op$.

The i-handler $h_i$ must contain a return clause that handles the case when the handled computation directly returns a value. It may also contain clauses that handle operations. For example, the clause $op(x, k) \mapsto c$ handles the operation $op$. More details can be found in the dynamic semantics section.

\subsection{Agent Specific Type Information}
We use agents to model a module system where each module can have private information about effect abstraction. Each agent in our language has limited knowledge of effect abstraction. For example, an agent i might knows that effect \li{Nondet = flip(): Bool}, and an agent $j$ does not have this information. As a result, agent i would be able to handle a computation with effect \li{Nondet}, while the agent j would not be able to do that. Furthermore, we need to ensure the consistency the information on effect abstraction, that is, agent j should not think that the effect \li{Nondet = read(): String}, which would contradict with the knowledge of agent i. 

The model of effect abstraction information is similar to the model of type information in \cite{grossman00}. To capture effect abstraction information, each agent $i$ has a partial function $\delta_i$ that maps an effect label to an effect type. There are two requirement for these maps: (1) For each effect label $f$, the if there are two agents that knows the implementation of the effect $f$, then there knowledge about the implementation must be the same. (2) For each effect label $f$, there is a unique and most concrete interpretation of $f$. We would not allow the effect label $f$ itself to appear in the implementation of $f$. Examples like $\delta_i(f) = \{f\}$ would be rejected.
\todo[inline]{Give an example of deltai that contains an f and an op}
\begin{definition}
A set $\{\delta_1, \dots, \delta_n\}$ of maps from effect labels to effects is \underline{compatible} if
\begin{enumerate}
\item For all $i, j \in 1 \dots n$ if $f \in Dom(\delta_i) \cap Dom(\delta_j)$, then $\delta_i(f) = \delta_i(j)$.
\item Effect labels can be totally ordered such that for every agent $i$ and effect label $f$, all effect labels in $\delta_i(f)$ precede $f$.
\end{enumerate}
\end{definition}

Then we define the a total function $\Delta_i$ that refines an effect type:
\begin{definition}
\begin{align*}
\Delta_i(\cdot) &= \cdot \\
\Delta_i(op, \varepsilon) &= op, \Delta_i(\varepsilon) \\
\Delta_i(f, \varepsilon) &= 
    \begin{cases}
      f, \Delta_i(\varepsilon) & \text{if}\ f \not\in Dom(\delta_i)  \ \\
      \varepsilon', \Delta_i(\varepsilon) & \text{if}\ \delta_i(f) = \varepsilon'
    \end{cases}
\end{align*}
\end{definition}

The definition of compatibility ensures that there is a fixpoint for repeatedly refining an effect label $f$ using the function $\Delta_i$. We call such fixpoint $\overline{\Delta_i}(f)$.

\todo[inline]{Show an example to apply Delta to get a fixpoint}
\todo[inline]{Explain the intuition: Collect all ops and abstract effects}


\begin{definition}
$\overline{\Delta_i}(f) = \varepsilon$ if there is some $n \geq 0$
\[
    \underbrace{\Delta_i(\dots (\Delta_i(f) \dots )}_\text{n applications}   = 
    \underbrace{\Delta_i(\dots (\Delta_i(f) \dots )}_\text{n+1 applications}   = \varepsilon
 \]
 \end{definition}
 
 We assume that the type information for operations are public to all agents. The type  for an operation $op$ is contained a separate map $\Sigma$, which maps an operation $op$ to an arrow type $\tau_A \rightarrow \tau_B$. Note that this is different from the function type in our calculus, which has the form $\tau \rightarrow \sigma$.




\section{Operational Semantics}
\begin{figure}[t]
\footnotesize{


$\fbox{$e \longrightarrow e'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Congruence)}]
  {[e_j]^\tau_j \longrightarrow [e_j']^\tau_j}
  {e_j \mapsto e_j'} \quad 

\infer[\textsc{(E-Unit)}]
  {[()_j]^{1}_j \longrightarrow ()_i}
  {} \\[3ex]
  
\infer[\textsc{(E-Lambda)}]
  {[\lambda x_j : \tau'.\ c_j]^{\tau \rightarrow \sigma}_{j} \longrightarrow \lambda x_i : \tau.\ [\{[x_i]^{\tau'}_{i}/x_j\}c_j]^\sigma_{j}}
  {} \\[3ex]
\end{array}
\]
}
\caption{Operational Semantics for Expressions}
\label{fig-op1}

\end{figure}

\begin{figure}[p]
\footnotesize{

$\fbox{$c \longrightarrow c'$}$
\[
\begin{array}{c}
\infer[\textsc{(E-Ret)}]
  {\texttt{return}\ e_i \longrightarrow \texttt{return}\ e_i'}
  {e_i \mapsto e_i'} \quad
  
\infer[\textsc{(E-Op)}]
  {op(e_i,y_i.c_i) \longrightarrow op(e_i', y_i, c_i)}
  {e_i \mapsto e_i'} \\[3ex]
 
 \infer[\textsc{(E-Embed1)}]
{[c_j]^\sigma_l \longrightarrow [c_j']^\sigma_l}
{c_j \longrightarrow c_j'} \quad 



\infer[\textsc{(E-Embed2)}]
{[\m{return} v_j]^{\{\varepsilon\}\tau}_l \longrightarrow \m{return} [v_j]^\tau_l}
{} \\[3ex]

\infer[\textsc{(E-Embed3)}]
{[op_j(v_j; y_j.c_j)]^{\{\varepsilon\}\tau}_j \longrightarrow [op_j]^\varepsilon_l([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_j)}
{ \Sigma(op) = \tau_A \rightarrow \tau_B} \\[3ex]

\infer[\textsc{(E-Embed4)}]
{[[op_k]^{\varepsilon'}_{l}(v_j; y_j.c_j)]^{\{\varepsilon\}\tau}_j \longrightarrow [op_k]^\varepsilon_{lj}([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_j)}
{ \Sigma(op) = \tau_A \rightarrow \tau_B& \Delta_j(\varepsilon') = \varepsilon' & op \not \in \varepsilon'} \\[3ex]




 
\infer[\textsc{(E-EmbedOp1)}]
{[op]^\varepsilon_l(e_i; y_i.c_i) \longrightarrow [op]^{\varepsilon}_l(e_i'; y_i.c_i) }
{e_i \longrightarrow e_i'} \quad
 
\infer[\textsc{(E-EmbedOp2)}]
{[op]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow [op]^{\varepsilon'}_l(v_i; y_i.c_i) }
{\overline{\Delta_i}(\varepsilon) = \varepsilon'} \\[3ex]

\infer[\textsc{(E-EmbedOp3)}]
{[op]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow op(v_i; y_i.c_i) }
{\Delta_i(\varepsilon) = \varepsilon & op \in \varepsilon} \quad

\infer[\textsc{(E-EmbedOp4)}]
{[op]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow [op]^{\varepsilon \setminus op'}(v_i; y_i.c_i) }
{\Delta_i(\varepsilon) = \varepsilon & op \not\in \varepsilon & op' \in \varepsilon} \\[3ex]


\infer[\textsc{(E-App1)}]
  {e_i\ e_i' \longrightarrow e_i''\ e_i'}
  {e_i \longrightarrow e_i''}  \quad
  
\infer[\textsc{(E-App2)}]
  {v_i \ e_i \longrightarrow v_i\ e_i'}
  {e_i\longrightarrow e_i'}  \quad
  
\infer[\textsc{(E-App3)}]
  {(\lambda x_i:\tau.\ c_i) \ v_i \longrightarrow \{v_i/x_i\}c_i}
  {} \\[3ex]
  
  
\infer[\textsc{(E-Seq1)}]
  {\texttt{do}\ x \leftarrow c_i\ \texttt{in}\ c_i' \longrightarrow \texttt{do}\ x \leftarrow c_i''\ \texttt{in} c_i'}
  {c_i \longrightarrow c_i''}  \quad
  
\infer[\textsc{(E-Seq2)}]
  {\texttt{do}\ x \leftarrow \texttt{return}\ v_i \ \texttt{in}\ c_i' \longrightarrow \{v_i/x\} c_i'}
  {} \\[3ex]
  
\infer[\textsc{(E-Seq3)}]
  {\texttt{do}\ x \leftarrow op_i(v_i; y_i.c_i) \texttt{in}\ c_i' \longrightarrow op_i(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i')}
  {} \\[3ex]
  
\infer[\textsc{(E-Seq4)}]
  {\texttt{do}\ x \leftarrow [op_j]^\varepsilon_l(v_i; y_i.c_i) \texttt{in}\ c_i' \longrightarrow [op_j]^\varepsilon_l(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i')}
  {\Delta_i(\varepsilon) = \varepsilon & op \not \in \varepsilon} \\[3ex]
  

  
 \infer[\textsc{(E-Handle1)}]
  {\m{with} h_i \m{handle} c_i \longrightarrow \m{with} h_i \m{handle} c_i' }
  {c_i \longrightarrow c_i'} \quad
  
\infer[\textsc{(E-Handle2)}]
  {\m{with} h_i \m{handle} \m{return} v_i \longrightarrow \{v_i/x_i\}c_i' }
  {\m{return} x_i \mapsto	c_i' \in h_i} \\[3ex]
  
\infer[\textsc{(E-Handle3)}]
  {\m{with} h_i \m{handle} op(v_; y_i.c_i) \longrightarrow \{v_i/x_i\} \{(\lambda y_i: \tau_B.
   \m{with} h_i\m{handle} c_i) / k\}c_i' }
  {op(x_i; k) \mapsto c_i' \in h_i & \Sigma(op) = \tau_A \rightarrow \tau_B} \\[3ex]
 
 
\infer[\textsc{(E-Handle4)}]
  {\m{with} h_i \m{handle} op(v_i, y_i.c_i) \longrightarrow op(v_i; y_i. \m{with} h_i \m{handle} c_i))}
  {op(x_i; k) \mapsto c_i' \not\in h_i } \\[3ex]
  
\infer[\textsc{(E-Handle5)}]
  {\m{with} h_i \m{handle} [op]^\varepsilon_l(v_i, y_i.c_i) \longrightarrow [op]^\varepsilon_l(v_i; y_i. \m{with} h_i \m{handle} c_i))}
  {\Delta_i(\varepsilon) = \varepsilon & op \not \in \varepsilon} \\[3ex]
  


\end{array}
\]

}
\caption{Operational Semantics for Computations}
\label{fig-op2}

\end{figure}

The reduction rules for terms are dependent on the agent of the terms. Figure \ref{fig-op1} shows that operational semantics for expressions of agent i. (E-Congurence) shows that a j-expression embedded agent-i should be evaluated using the reductions rules for agent j first. The (E-Unit) and (E-Lambda) rules show that we can lift an embedded j-value to agent i, so the value becomes an i-value. The (E-Unit) rule simply lifts the unit value out of the embedding. The (E-Lambda) rule is more interesting: The value embedded is a lambda expression of agent j. We lift the argument out of the embedding. However, the type annotating the argument is changed from $\tau'$ to the exported argument type $\tau$, because the reduced expression should have the exported type $\tau \rightarrow \sigma$. The body of the reduced expression is an embedded j-computation, so the variable $x_i$ should be encapsulated by an embedding, because any i-term should be embedded in a j-term. We annotate $x_i$ with type $tau'$ because the original lambda function expects a value of type $tau'$. 

Figure \ref{fig-op2} shows the reduction rules for i-computations. (E-Ret) is the congruence rule that evaluates the expression in return statement. (E-Op) evaluates the input argument for the operation call. Note that there are no reduction rules for operation calls because the semantics for operations are defined by the handler encapsulating it. 

(E-Embed1) is the congruence rule for embedded computations. (E-Embed2) lifts the return statement out of the embedding. We can safely remove the effect annotation $\varepsilon$ because the returned value $v_j$ cannot cause any effect. 

(E-Embed3) lifts an operation call out of the embedding. We annotate the operation with the effect annotation of the whole computation. Since the argument value for $op$ is a j-value, we need to embed it as a i-value, and annotate it with type $\tau_A$. The continuation $c_j$ is still embedded, and we substitute the embedded variable $y_i$ for $y_j$, because $y_i$ should be an embedded i-value in a j-value.

The (E-Embed4) rule is very similar to (E-Embed3) with one difference being that $op$ is already embedded. In this case, we override the annotation on $op$ with the annotation for the whole computation, and update the agent list in the subscript of the operation. We add $j$ to the agent list because the agent j have contributed to the effect annotation of the operation.


(E-EmbedOp1) evaluates the argument expression to an embedded operation. (E-EmbedOp2) refines the effect annotation of an operation. (E-EmbedOp3) lifts the operation out of an embedding when the annotation contains the operation, because the agent i has enough information about effect abstraction to handle the operation. Note that we require that the effect annotation cannot be further refined, in order to ensure determinism of evaluation. (E-EmbedOp4) removes an operation that is not $op$ out of the effect annotation, as this is helpful in our proof of type soundness.

(E-App1), (E-App2) and (E-App3) are standard call-by-value semantics for applications. (E-Seq1) evaluates the first computation in a sequence of computations. (E-Seq2) binds the return value of the first computation to a variable in the second computation. (E-Seq3) witnesses an operation call as the first computation in a sequence. Since there is no way to further evaluate an operation right away, we propagate the operation call outwards and defer further evaluation to the continuation of the call. (E-Seq4) is similar to (E-Seq3), and requires that the effect annotation on the embedding to be most precise. 

(E-Handle1) simply evaluates the computation encapsulated by the handler. In (E-Handle2), the computation returns a value, so we substitute the value into the computation of the clause that handles the return statement in the handler. (E-Handle3) shows that case when the handler $h_i$ has a matching clause for the operation $op$. We substitute the argument $v_i$ for $x_i$, and substitute the continuation of the operation for $k$. The continuation function receives an argument of type $\tau_B$, which is the result type of the operation $op$, and computes the continuation of the operation $c_i$, but encapsulating it with the handler $h_i$. The (E-Handle4) shows the case when the operation is not handled by the handler, so we propagate the operation outwards to wait for another handler to handle it. The (E-Handler5) ensures that abstracted effects are not handled: If the current agent cannot refine the effect annotation, then the operation is abstract and cannot be handled, and is therefore propagated outward. 



\section{Static Semantics}
\subsection{Typing Rules}

\begin{figure}[t]
\footnotesize{
\noindent$\fbox{$\Gamma \vdash e_i : \tau$}$
\[
\begin{array}{c}

\infer[\textsc{(T-unit)}]
  {\Gamma \vdash ()_i : 1}
  {} \quad 

\infer[\textsc{(T-var)}]
  {\Gamma \vdash x_i : \Gamma(x_i)}
  {} \quad 

\infer[\textsc{(T-lam)}]
  {\Gamma \vdash (\lambda x_i: \tau.\ c_i) : \tau \rightarrow \sigma}
  {\Gamma, x_i:\tau \vdash c_i : \sigma} \\[3ex]
  
\infer[\textsc{(T-EmbedExp)}]
  {\Gamma \vdash [e_j]^\tau_j : \tau}
  {\Gamma \vdash e_j : \tau' & \Gamma \vdash \tau' \leq_{ji} \tau} \quad  
\end{array} \\[3ex]
\]


\noindent$\fbox{$\Gamma \vdash c_i : \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(T-ret)}]
  {\Gamma\vdash \m{return} e_i : \{\varepsilon\}\tau }
  {\Gamma\vdash e_i : \tau & \Delta_i(\varepsilon) = \varepsilon} \quad 
  
\infer[\textsc{(T-op)}]
  {\Gamma\vdash op(e_i; y_i.c_i) : \{\varepsilon\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon\}\tau & op \in \Delta_i(\varepsilon)} \\[3ex]


\infer[\textsc{(T-seq)}]
  {\Gamma\vdash \m{do} x_i \leftarrow c_i \m{in} c_i' : \{\varepsilon\}\tau' }
  {\Gamma \vdash c_i : \{\varepsilon\}\tau & \Gamma, x_i:\tau \vdash c_i': \{\varepsilon\}\tau'} \quad 
  
  
\infer[\textsc{(T-app)}]
  {\Gamma\vdash e_1\ e_2\ : \sigma }
  {\Gamma \vdash e_1 : \tau \rightarrow \sigma & \Gamma \vdash e_2 : \tau} \\[3ex]
  
\infer[\textsc{(T-handle)}]
  {\Gamma\vdash \m{with} h_i \m{handle} c_i: \{\varepsilon'\} \tau_B}
  {\begin{gathered}
  h_i = \{\m{return} x \mapsto c^r, op^1(x;k) \mapsto c^1, \dots, op^n(x;k) \mapsto c^n \}\\
  \Gamma, x: \tau_A \vdash c^r : \{\varepsilon'\}\tau_B \quad
  \left\{ \Sigma(op^i) = \tau_i \rightarrow \tau_i'  \quad \Gamma, x:\tau_i, k:\tau_i' \rightarrow \{\varepsilon'\}\tau_B \vdash c^i: \{\varepsilon'\}\tau_B    \right\}_{1 \leq i \leq n} \\
  \Gamma \vdash c_i : \{\varepsilon\}\tau_A \quad \varepsilon \setminus \{op^i\}_{1 \leq i \leq n} \subseteq \varepsilon'
  \end{gathered}} \\[3ex]
  
\infer[\textsc{(T-Embed)}]
  {\Gamma\vdash [c_j]^\sigma_l : \sigma }
  {\Gamma \vdash c_j : \sigma' & \Gamma \vdash \sigma' \leq_{li} \sigma  } \\[3ex]
  
\infer[\textsc{(T-EmbedOp)}]
  {\Gamma\vdash [op]^\varepsilon_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma,y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau & \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon') & \Gamma \vdash op \leq_{li} \varepsilon} \\[3ex]
  
\end{array} \\[3ex]
\]
}


\caption{Static Semantics}
\label{wrap-static}
\end{figure}

Figure \ref{wrap-static} shows the static semantics of the core-calculus. Static semantics contains typing rules for both expressions and computations. Note that the type rules depend on the agent each expression or computation belongs to. 

The rule (T-Unit) assigns the unit type to a unit value. (T-Var) looks up a type of a variable from the context. (T-Lam) is the standard rule for typing a lambda function. Note that the body of a lambda is computation, so we need use the typing judgement for computation in the premise of this rule. (T-EmbedExp) assigns type to expression embeddings: The embedding has type $tau$ if the embedded expression $e_j$ is assigned to the type $\tau'$, and $tau$ is related to $tau'$ by the list $li$. We will elaborate on type relations later. 

(T-Ret) assign a type to a return statement: As expected, the expression part of the computation type matches the type of the returned expression. However we can annotate the return statement with an arbitrary effect set, because our type system does not describe the precise effect in computations, but gives the upper bound of effect in computations.  

(T-Op) shows the typing rule for operation calls. Again, since we allow effect annotations to be an unpper bound on effect, we can require the operation $op$ to be in the effect set $\varepsilon$.

(T-Handle) shows the typing rule for the effect handling statement $\m{with} h_i \m{handle} c_i$. $c_i$ is a computation with effect type $\varepsilon$ and return type $\tau_A$. $h_i$ is a handler that contains clause that handler operations $op^1 , \dots ,op^n$. For the return clause, given the type of variable $x$ is $\tau_A$, the type of $c^r$ must be $\{\varepsilon'\}\tau_B$. For the clause handling the operation $op^i$, which has the operation type $\tau_i \rightarrow \tau_i'$,  if variable $x$ has type $\tau_i$, and continuation has the type $\tau_i' \rightarrow \{\varepsilon'\}\tau_B$, then the handling computation $c^i$ must have the type $\{\varepsilon'\}\tau_B$. The effect type after handling, $\varepsilon'$ should contain all of the effects that are not handled by the handler.

(T-Embed) is very similar to (T-EmbedExp), where we use the type of the embedded computation and the type relation judgment to assign a type to the embedding. 

(T-EmbedOp) first computes the type of $c_i$ given that $y_i$ has the correct type. It is required that the effect annotation on the embedding is a part of the effect of $c_i$. And $op$ should be related to the effect annotation using the type relations.

\subsection{Type Relations}
\begin{figure}[H]
\footnotesize{
\noindent$\fbox{$\tau \leq_l \tau'$}$
\[
\begin{array}{c}

\infer[\textsc{(R-unit)}]
	{1 \leq_l 1}
	{} \quad

\infer[\textsc{(R-arrow)}]
	{\tau \rightarrow \sigma \leq_l \tau' \rightarrow \sigma'}
	{\tau \leq_l \tau' & \sigma \leq_l \sigma'}
  
\end{array} \\[3ex]
\]

\noindent$\fbox{$\sigma \leq_l \sigma$}$
\[
\begin{array}{c}

\infer[\textsc{(R-sigma)}]
	{\{\varepsilon\}\tau \leq_l \{\varepsilon'\}\tau'}
	{ \varepsilon \leq_l \varepsilon' & \tau \leq_l \tau' } \quad
  
\end{array} \\[3ex]
\]

\noindent$\fbox{$\varepsilon \leq_l \varepsilon$}$
\[
\begin{array}{c}

\infer[\textsc{(R-eff1)}]
	{\varepsilon \leq_i \varepsilon'}
	{ \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon')  } \quad

\infer[\textsc{(R-eff2)}]
	{\varepsilon \leq_{ll'} \varepsilon'}
	{  \varepsilon \leq_l \varepsilon'' &   \varepsilon'' \leq_{l'} \varepsilon' } \quad
\end{array} \\[3ex]
\]
}

\caption{Type Relations}
\label{wrap-static}
\end{figure}

Type relations ensures the soundness of abstraction. The goal of type relations is to prohibit embeddings from exporting incorrect effect abstractions. For example, if a i-computation uses an effect operation $flip : 1 \rightarrow bool$, it should annotate the computation with effect $Nondet$ when exporting the computation, but should not  annotate it with the empty effect.

The judgements for expression types are of the form $\tau \leq_l \tau$, where $l$ is a list of agents that provide the type abstraction information used by the relation. (R-Unit) shows that unit types relates to itself. (R-Arrow) relates two arrow types given that the input types and the output types are related,  To relate two computation types, we just need to ensure the effect types and return types are related. 

The relation for effect types does the actual work. By (R-EFF1), two effect types are related under a single agent $i$ if the first effect is a subset of the second effect after refined by the type information provided by $i$. (R-EFF2) shows that by using type information from a list of agents, we can combine the chain of relation between effects.

\section{Safety Properties}
In this section we state and prove the standard type-safety theorems for the core calculus.
\begin{lemma} (Substitution) \\
If $\Gamma, x_j : \tau' \vdash c_i : \sigma$ and $\Gamma \vdash e_j : \tau'$, then $\Gamma \vdash \{e_j/x_j\}c_i : \sigma$, and\\\
If $\Gamma, x_j : \tau' \vdash e_i : \tau $ and $\Gamma \vdash e_j : \tau'$, then $\Gamma \vdash \{e_j/x_j\}e_i : \tau$

\begin{proof}
By rule induction on $\Gamma \vdash e : \tau$ and $\Gamma \vdash c : \sigma$
\begin{enumerate}[align=left]
\item[(T-Unit)] Trivial
\item[(T-Var)] Trivial
\item[(T-Lam)] 
$$
\infer[\textsc{(T-lam)}]
  {\Gamma, x_j : \tau'  \vdash (\lambda x_i: \tau.\ c_i) : \tau \rightarrow \sigma}
  {\Gamma,x_j : \tau',  x_i:\tau \vdash c_i : \sigma} 
$$
By IH, we have $\Gamma, x_i:\tau \vdash \{e_j/x_j\}c_i : \sigma$\\
Then by (T-Lam) we have $\Gamma \vdash (\lambda x_i : \tau.\ \{e_j/x_j\}c_i) : \sigma$.\\
Which is equivalent to $\Gamma \vdash \{e_j/x_j\}(\lambda x_i : \tau.\ c_i) : \sigma$.
\item[(T-EmbedExp)] By inversion and IH
\item[(T-Ret)] Follows by induction hypothesis
\item[(T-Op)]  
$$
\infer[\textsc{(T-op)}]
  {\Gamma\vdash op(e_i; y_i.c_i) : \{\varepsilon\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon\}\tau & op \in \Delta_i(\varepsilon)} 
$$

By inversion we have $\Gamma, x_j : \tau' \vdash e_i : \tau_A$ and $\Gamma, x_j : \tau', y_i : \tau_B \vdash c_i : \{\varepsilon\} \tau$. \\
Since we can make $y_i$ a fresh variable, we have $\Gamma,  y_i : \tau_B, x_j:\tau' \vdash c_i : \{\varepsilon\} \tau$.\\
Then by IH we have $\Gamma \vdash \{e_j/x_j\}e_i : \tau_A$ and $\Gamma,  y_i : \tau_B \vdash \{e_j/x_j\}c_i : \{\varepsilon\} \tau$.\\
By (T-Op) we have $\Gamma \vdash op(\{e_j/x_j\}e_i; y_i.\{e_j/x_j\}c_i) : \{\varepsilon\}\tau$\\
Therefore we have $\Gamma \vdash \{e_j/x_j\}(op(e_i; y_i.c_i)) : \{\varepsilon\}\tau$

\item[(T-Seq)] 
$$
\infer[\textsc{(T-seq)}]
  {\Gamma, x_j : \tau'' \vdash \m{do} x_i \leftarrow c_i \m{in} c_i' : \{\varepsilon\}\tau' }
  {\Gamma, x_j : \tau'' \vdash c_i : \{\varepsilon\}\tau & \Gamma, x_j : \tau'', x_i:\tau \vdash c_i': \{\varepsilon\}\tau'} 
  $$
By IH, we have $\Gamma \vdash \{e_j/x_j\}c_i : \{\varepsilon\}\tau$\\
Since we can choose $x_i$ as a fresh variable, we have $\Gamma, x_i : \tau, x_j : \tau'' \vdash c_i': \{\varepsilon\}\tau'$\\
Then by IH we have  $\Gamma, x_i : \tau \vdash \{e_j/x_j\}c_i': \{\varepsilon\}\tau'$\\
Then the result follows by (T-Seq)
\item[(T-App)] Follows directly by applying IH.
\item[(T-Handle)] 
$$
\infer[\textsc{(T-handle)}]
  {\Gamma, x_j : \tau' \vdash \m{with} h_i \m{handle} c_i: \{\varepsilon'\} \tau_B}
  {\begin{gathered}
  h_i = \{\m{return} x \mapsto c^r, op^1(x;k) \mapsto c^1, \dots, op^n(x;k) \mapsto c^n \}\\
  \Gamma, x_j : \tau' , x: \tau_A \vdash c^r : \{\varepsilon'\}\tau_B \\
  \left\{ \Sigma(op^i) = \tau_i \rightarrow \tau_i'  \quad \Gamma, x_j : \tau', x:\tau_i, k:\tau_i' \rightarrow \{\varepsilon'\}\tau_B \vdash c^i: \{\varepsilon'\}\tau_B    \right\}_{1 \leq i \leq n} \\
  \Gamma, x_j : \tau' \vdash c_i : \{\varepsilon\}\tau_A \quad \varepsilon \setminus \{op^i\}_{1 \leq i \leq n} \subseteq \varepsilon'
  \end{gathered}}
  $$
    Then handling clauses bind variables $x$ and $k$ in the handling computation $c^i$, so we can make them fresh variables that do not appear in context $\Gamma$. Then we can apply IH to typing judgements in the premise.
    
\item[(T-Embed)] Follows by applying IH
\item[(T-EmbedOp)] The proof is similar to  the case for (T-Op)

\end{enumerate}
\end{proof}
\end{lemma}

\begin{lemma} 
\label{lemma-exact}
If $\Gamma \vdash c_i : \{\varepsilon\}\tau$ then $\overline{\Delta_i}(\varepsilon) = \varepsilon$
\begin{proof}
By induction on derivation of $\Gamma \vdash c : \sigma$. (T-Ret) has a premise the ensures the lemma is correct. For other rules, the result is immediate by applying IH.

\end{proof}
\end{lemma}

\begin{lemma}
\label{lemma-minus}
If $\varepsilon \leq_l \varepsilon'$, then $\varepsilon \setminus op \leq_l \varepsilon' \setminus op$
\begin{proof}
By induction on $\varepsilon \leq_l \varepsilon$. The proof is straightforward.
\end{proof}

\end{lemma}

\begin{lemma}
\label{lemma-relation}
If $op \leq_{l} \varepsilon$, then $op \leq_{l} \varepsilon \setminus op'$
\begin{proof}
By induction on the derivation of $\varepsilon \leq_l \varepsilon$. If (R-Eff1) is used, then the proof is straightforward because the subset relation on the premise still holds. If (R-Eff2) is used, by inversion on (R-Eff2), we have $op \leq_l \varepsilon'$ and $\varepsilon' \leq_{l'} \varepsilon$. By IH we have $op \leq_l \varepsilon' \setminus op'$. By lemma \ref{lemma-minus} we have $\varepsilon'  \setminus op' \leq_{l'} \varepsilon \setminus op'$. Then the result follows by (R-Eff2)
\end{proof}
\end{lemma}

\begin{lemma}
\label{lemma-relation2}
If $\tau \leq_l \tau'$ then $\tau' \leq_{rev(l)} \tau$
\begin{proof}
By induction on the type relation rules. The proof is simple arguments that follow directly from IH.  
\end{proof}
\end{lemma}

\begin{lemma} (Preservation for expressions) \\
For all agent $i$, If $\Gamma \vdash e_i : \tau$ and $e_i \mapsto e_i'$, then $\Gamma \vdash e_i' : \tau$.
\begin{proof}
By induction on derivation of $e_i \mapsto e_i'$
\begin{enumerate}[align=left]
\item[(E-Congruence)] By inversion on the typing rule for embedded expressions, we have $\Gamma \vdash e_j : \tau'$. By IH, we have $\Gamma \vdash e_j' : \tau'$. Then we use (E-Contruence) to derive $\Gamma \vdash [e_j']^\tau_j : \tau$

\item[(E-Unit)] Follows immediately from  (T-Unit)
\item[(E-Lambda)] By inversion on (T-Embed), we have $\Gamma \vdash \lambda x_j:\tau'.\ c_j : \tau' \rightarrow \sigma'$, where $\tau' \rightarrow \sigma' \leq_{ji} \tau \rightarrow \sigma$.\\
By inversion on (R-Arrow), we have $\tau' \leq_{ji} \tau$ and $\sigma' \leq_{ji} \sigma$\\
By inversion on (T-Lambda), we have $\Gamma, x_j : \tau' \vdash c_j : \sigma'$. And since $x_i$ is a fresh variable in $c_j$, we have $\Gamma, x_i : \tau, x_j : \tau' \vdash c_j : \sigma'$\\
By lemma \ref{lemma-relation2}, we have $\tau \leq_{ij} \tau'$, and therefore $\Gamma, x_i : \tau \vdash [x_i]^{\tau'}_i : \tau'$\\
Then we can use the substitution lemma to derive $\Gamma, x_i : \tau \vdash \{[x_i]^{\tau'}_i / x_j\}c_j : \sigma'$.\\
Then by (T-Embed), we have $\Gamma, x_i : \tau \vdash [  \{[x_i]^{\tau'}_i / x_j\}c_j ]^\sigma_j : \sigma$\\
Then the result follows by (T-Lambda).

\end{enumerate}
\end{proof}
\end{lemma}

\begin{lemma} (Preservation for computations) \\
If $\Gamma \vdash c_i : \{\varepsilon\} \tau$ and $c_i \longrightarrow c_i'$, then $\Gamma \vdash c_i' : \{\varepsilon\}\tau$

\begin{proof} (Sketch)
By induction on the derivation that $c_i \longrightarrow c_i'$. We proceed by the cases on the last step of the derivation.

\begin{enumerate}
\item E-Ret: By inversion, $\Gamma \vdash e_i: \tau$. By preservation of expressions and IH, we have  $\Gamma \vdash e_i': \tau$. Then we can use E-Ret to derive $\Gamma  \vdash c_i' : \{\varepsilon\} \tau$
\item E-Op: Follow immediately from inversion and IH
\item E-EmbedOp1: Follow immediately from inversion and IH
\item E-EmbedOp2:  
$$\infer[\textsc{(E-EmbedOp2)}]
{[op_j]^\varepsilon_l(v_i; y_i.c_i) \longrightarrow [op_j]^{\varepsilon''}_l(v_i; y_i.c_i) }
{\overline{\Delta_i}(\varepsilon) = \varepsilon''} \quad $$
We have the typing rule as follows:
$$\infer[\textsc{(T-EmbedOp)}]
  {\Gamma\vdash [op]^\varepsilon_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau & \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon') & \Gamma \vdash op \leq_{li} \varepsilon}  $$
  Since $\overline{\Delta_i}(\varepsilon'') = \varepsilon''$ and $\varepsilon'' = \overline{\Delta_i}(\varepsilon)$, we have $\overline{\Delta_i}(\varepsilon'')  \subseteq \overline{\Delta_i}(\varepsilon')$. Then we can use T-EmbedOp to derive $\Gamma\vdash [op]^{\varepsilon''}_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau $
\item E-EmbedOp3:
  We have the typing rule as follows:
$$\infer[\textsc{(T-EmbedOp)}]
  {\Gamma\vdash [op]^\varepsilon_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau & \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon') & \Gamma \vdash op \leq_{li} \varepsilon}  $$
  By E-EmbedOp3, $op \in \overline{\Delta_i}(\varepsilon)$. So $op \in \overline{\Delta_i}(\varepsilon')$. 
By inversion on the typing rule, we have $\Gamma, y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau$. By lemma \ref{lemma-exact}, we have $\Gamma, y_i:\tau_B\vdash c_i: \{\overline{\Delta_i}(\varepsilon')\}\tau$. Then we can use T-Op to derive the designed result $\Gamma \vdash op(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau $

\item E-EmbedOp4:
We have the typing rule as follows:
$$\infer[\textsc{(T-EmbedOp)}]
  {\Gamma\vdash [op]^\varepsilon_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau }
  {\Sigma(op) = \tau_A \rightarrow \tau_B & \Gamma \vdash e_i : \tau_A & \Gamma. y_i:\tau_B\vdash c_i: \{\varepsilon'\}\tau & \overline{\Delta_i}(\varepsilon) \subseteq \overline{\Delta_i}(\varepsilon') & \Gamma \vdash op \leq_{li} \varepsilon}  $$
By lemma \ref{lemma-relation}, we have $op \leq_{li} \varepsilon \setminus op'$. By inversion on the typing rule, we have $\Gamma, y_i:\tau_B \vdash c_i:\{\varepsilon'\}\tau$ and $\varepsilon \subseteq \overline{\Delta_i}(\varepsilon')$.  So $\varepsilon \setminus op' \subseteq \overline{\Delta_i}(\varepsilon')$. By lemma \ref{lemma-exact}, we have $\Gamma, y_i:\tau_B \vdash c_i:\{\overline{\Delta_i}(\varepsilon')\}\tau$. Then we can apply T-EmbedOp again to derive $\Gamma\vdash [op]^{\varepsilon \setminus op'}_l(e_i; y_i.c_i) : \{\overline{\Delta_i}(\varepsilon')\}\tau $
  
\item E-App1: Follows immediately by T-App
\item E-App2: Follows immediately by T-App
\item E-App3: By inversion of T-App, we $\Gamma \vdash (\lambda x_i: \tau.\ c_i) : \tau \rightarrow \sigma$, $\Gamma \vdash v_i : \tau$. By inversion of T-Lam, $\Gamma, x_i:\tau \vdash c_i : \sigma$. By substitution lemma, we have $\Gamma \vdash \{v_i/x_i\}c_i : \sigma$.

\item E-Seq1:  Follows immediately by T-Seq and IH.
\item E-Seq2: By inversion on T-Seq, we have $\Gamma \vdash \m{return} v_i : \{\varepsilon\}\tau$ and $\Gamma, x_i:  \tau \vdash c_i': \{\varepsilon\}\tau'$. By inversion on T-Ret, we have $\Gamma \vdash v_i: \tau$. Then by substitution lemma we have $\Gamma \vdash \{v_i/x\}c_i' : \{\varepsilon\}\tau'$.
\item E-Seq3: 
$$
\infer[\textsc{(E-Seq3)}]
  {\texttt{do}\ x \leftarrow op_i(v_i; y_i.c_i) \texttt{in}\ c_i' \longrightarrow op_i(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i')}
  {} $$
  By inversion of T-Seq, we have $\Gamma \vdash op_i(v_i; y_i.c_i) : \{\varepsilon\}\tau$  and $\Gamma , x:\tau \vdash c_i' : \{\varepsilon\}\tau'$. By inversion on T-OP, we have $\Gamma, y_i: \tau_B \vdash c_i: \{\varepsilon\}\tau$ and $op \in \varepsilon$ and $\Gamma \vdash v_i : \tau_A$.  Then by T-Seq, we have $\Gamma, y_i : \tau_B \vdash \m{do} x \leftarrow c_i \m{in} c_i' : \{\varepsilon\}\tau'$. Then we can use T-Op to derive $\Gamma \vdash op_i(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i') : \{\varepsilon\}\tau'$.

\item E-Seq4
$$
\infer[\textsc{(E-Seq4)}]
  {\texttt{do}\ x \leftarrow [op_j]^\varepsilon_l(v_i; y_i.c_i) \texttt{in}\ c_i' \longrightarrow [op_j]^\varepsilon_l(v_i; y_i. \m{do} x \leftarrow c_i \m{in} c_i')}
  {\Delta_i(\varepsilon) = \varepsilon & op \not \in \varepsilon} $$
$$
\infer[\textsc{(T-seq)}]
  {\Gamma\vdash \m{do} x_i \leftarrow c_i \m{in} c_i' : \{\varepsilon'\}\tau' }
  {\Gamma \vdash c_i : \{\varepsilon'\}\tau & \Gamma, x_i:\tau \vdash c_i': \{\varepsilon'\}\tau'}  $$
By inversion on T-Seq, we have $\Gamma \vdash [op_j]^\varepsilon_l(v_i; y_i.c_i): \{\varepsilon'\}\tau$ and $\Gamma, x:\tau \vdash c_i' : \{\varepsilon'\} \tau'$. Then by inversion on T-EmbedOp, we have $\Gamma, y_i:\tau_B \vdash c_i: \{\varepsilon'\}\tau$, $\overline{\Delta_i}(\varepsilon) \subseteq \varepsilon'$.
Then by T-Seq, we have $\Gamma, y_i:\tau_B \vdash \m{do} x \leftarrow c_i \m{in} c_i' : \{\varepsilon'\}\tau'$. Then by T-EmbedOp, we have $\Gamma \vdash [op]^\varepsilon_l(v_i; y_i.  \m{do} x \leftarrow c_i \m{in} c_i' ): \{\varepsilon'\}\tau'$

\item E-Handle1: Follows immediately by inversion on T-Handle and IH
\item E-Handle2: By T-Handle, we have $\Gamma \vdash \m{with} h_i \m{handle} \m{return} v_i :  \{\varepsilon'\}\tau_B$. By inversion on T-Handle, we have $\Gamma, x_i:\tau_A \vdash c_i' : \{\varepsilon\}\tau_B$, and $\Gamma \vdash \m{return} v_i : \{\varepsilon\} \tau_A$. By inversion on T-Ret, we have $\Gamma \vdash v_i : \tau_A$. Then by substitution lemma, we have $\Gamma \vdash \{v_i/x_i\}c_i' : \{\varepsilon'\}\tau_B$. 

\item E-Handle3
$$
\infer[\textsc{(E-Handle3)}]
  {\m{with} h_i \m{handle} op(v_; y_i.c_i) \longrightarrow \{v_i/x_i\} \{(\lambda y_i: \tau_i'.
   \m{with} h_i\m{handle} c_i) / k\}c_i' }
  {op(x_i; k) \mapsto c_i' \in h_i & \Sigma(op) = \tau_i \rightarrow \tau_i'} 
$$
By T-Handle, we have $\Gamma \vdash \m{with} h_i \m{handle} op(v;y_i.c_i) :  \{\varepsilon'\}\tau_B$. By inversion on T-Handle, we have $\Gamma, x_i:\tau_i, k: \tau_i' \rightarrow \{\varepsilon'\}\tau_B \vdash c_i' : \{\varepsilon'\} \tau_B$, and $\Gamma \vdash op(v; y_i.c_i) : \{\varepsilon\} \tau_A$. By inversion on T-Op, we have $\Gamma \vdash v_i : \tau_i$ and $\Gamma, y_i: \tau_i' \vdash c_i: \{\varepsilon\}\tau_A$. By T-Handle, we have $\Gamma, y_i: \tau_i' \vdash \m{with} h_i \m{handle} c_i : \{\varepsilon'\}\tau_B$. Then by T-Lam, we have $\Gamma \vdash \lambda y_i:\tau_i'.\ \m{with} h_i \m{handle} c_i : \tau_i' \rightarrow  \{\varepsilon'\}\tau_B$. Then, by substitution lemma, we have $\Gamma \vdash \{v_i/x_i\} \{(\lambda y_i: \tau_i'.
   \m{with} h_i\m{handle} c_i) / k\}c_i' : \{\varepsilon'\}\tau_B$.
   
\item E-Handle4:
$$
\infer[\textsc{(E-Handle4)}]
  {\m{with} h_i \m{handle} [op]^\varepsilon_l(v_i, y_i.c_i) \longrightarrow [op]^\varepsilon_l(v_i; y_i. \m{with} h_i \m{handle} c_i))}
  {\Delta_i(\varepsilon) = \varepsilon & op \not \in \varepsilon} 
$$

$$
\infer[\textsc{(T-handle)}]
  {\Gamma\vdash \m{with} h_i \m{handle} c_i: \{\varepsilon'\} \tau_B}
  {\begin{gathered}
  h_i = \{\m{return} x \mapsto c^r, op^1(x;k) \mapsto c^1, \dots, op^n(x;k) \mapsto c^n \}\\
  \Gamma, x: \tau_A \vdash c^r : \{\varepsilon'\}\tau_B \quad \\
  \left\{ \Sigma(op^i) = \tau_i \rightarrow \tau_i'  \quad \Gamma, x:\tau_i, k:\tau_i' \rightarrow \{\varepsilon'\}\tau_B \vdash c^i: \{\varepsilon'\}\tau_B    \right\}_{1 \leq i \leq n} \\
  \Gamma \vdash c_i : \{\varepsilon''\}\tau_A \quad \varepsilon'' \setminus \{op^i\}_{1 \leq i \leq n} \subseteq \varepsilon'
  \end{gathered}}
$$
By T-Handle, we have $\Gamma \vdash \m{with} h_i \m{handle} [op]^\varepsilon_l(v;y_i.c_i) :  \{\varepsilon'\}\tau_B$. By inversion on T-Handle, we have $\Gamma \vdash [op]^\varepsilon_l(v;y_i.c_i): \{\varepsilon''\}\tau_A$ and $\varepsilon'' \setminus \{op^i\} \subseteq \varepsilon'$. By inversion on T-EmbedOp, we have $\Gamma \vdash v_i: \tau_i$, $\Gamma, y_i:\tau_i' \vdash c_i : \{\varepsilon''\}\tau_A$ and $\varepsilon \subseteq \varepsilon''$. Since $\varepsilon$ doesn't contain any concrete operation, we have $\varepsilon \subseteq  \varepsilon'' \setminus \{op^i\} \subseteq \varepsilon' $. Then by T-Handle, we have $\Gamma, y_i: \tau_i' \vdash \m{with} h_i \m{handle} c_i : \{\varepsilon'\}\tau_B$. Then, we use T-EmbedOp to derive $\Gamma \vdash [op]^\varepsilon_l(v_i; y_i. \m{with} h_i \m{handle} c_i) : \{\varepsilon'\}\tau_B$


\item E-Embed1: Follows immediately from Inversion and IH
\item E-Embed2: By typing rule, we have $\Gamma \vdash [\m{return} v_j]^{\{\varepsilon\}\tau}_l :\{\varepsilon\}\tau$. By inversion on the typing rule, we have $\Gamma \vdash \m{return} v_j : \{\varepsilon'\}\tau'$ such that $\{\varepsilon\}\tau' \leq_{li} \{\varepsilon\}\tau$. By inversion on R-Sigma, we have $\tau' \leq_{li} \tau$. Then by T-EmbedExp, we have $\Gamma \vdash [v_j]^\tau_l : \tau$. Then by T-Ret, we have $\Gamma \vdash \m{return}  [v_j]^\tau_l : \{\varepsilon\}\tau$. $\Gamma \vdash [\m{return} v_j]^{\{\varepsilon\}\tau}_l :\{\varepsilon\}\tau$

\item E-Embed3: 
$$
\infer[\textsc{(E-Embed3)}]
{[op(v_j; y_j.c_j)]^{\{\varepsilon\}\tau}_l \longrightarrow [op]^\varepsilon_l([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_l)}
{ \Sigma(op) = \tau_A \rightarrow \tau_B} 
$$
By typing rule, we have $\Gamma \vdash op(v_j; y_j.c_j) : \{\varepsilon'\}\tau'$, where $\{\varepsilon'\}\tau' \leq_{li} \{\varepsilon\}\tau$. By inversion on T-Op, we have $\Gamma \vdash v_j : \tau_A$, and $\Gamma, y_j : \tau_B \vdash c_j: \{\varepsilon'\}\tau'$. Then, by T-EmbedExp, we have $\Gamma \vdash [v_j]^{\tau_A}_j : \tau_A$. By substitution lemma, we have $\Gamma, y_i: \tau_B \vdash \{[y_i]^{\tau_B}_i/y_j\}c_j : \{\varepsilon'\}\tau'$. By T-Embed, we have $\Gamma, y_i: \tau_B \vdash \{[y_i]^{\tau_B}_i/y_j\}[c_j]^{\{\varepsilon\}\tau}_l : \{\varepsilon\}\tau$. Then we can use T-EmbedOp to derive $\Gamma \vdash [op]^\varepsilon_l([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_l): \{\varepsilon\}\tau$. 

\item E-Embed4:
$$
\infer[\textsc{(E-Embed4)}]
{[[op_k]^{\varepsilon'}_{l'}(v_j; y_j.c_j)]^{\{\varepsilon\}\tau}_l \longrightarrow [op_k]^\varepsilon_{l'jl}([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_l)}
{ \Sigma(op_k) = \tau_A \rightarrow \tau_B& \Delta_j(\varepsilon') = \varepsilon' & op \not \in \varepsilon'} 
$$
By typing rule, we have $\Gamma \vdash [op_K]^{\varepsilon'}_{l'}(v_j; y_j.c_j) : \{\varepsilon''\}\tau''$, where $\{\varepsilon''\}\tau'' \leq_{li} \{\varepsilon\}\tau$. By inversion on T-EmbedOp, we have $\Gamma \vdash v_j: \tau_A$ and $\Gamma, y_j : \tau_B \vdash c_j: \{\varepsilon''\}\tau''$. Then, by T-EmbedExp, we have $\Gamma \vdash [v_j]^{\tau_A}_j : \tau_A$.
By substitution lemma, we have $\Gamma, y_i: \tau_B \vdash \{[y_i]^{\tau_B}_i/y_j\}c_j : \{\varepsilon''\}\tau''$. By T-Embed, we have $\Gamma, y_i: \tau_B \vdash \{[y_i]^{\tau_B}_i/y_j\}[c_j]^{\{\varepsilon\}\tau}_l : \{\varepsilon\}\tau$. Then we use T-EmbedOp to derive $\Gamma \vdash [op_k]^\varepsilon_{l'jl}([v_j]^{\tau_A}_j; y_i. \{[y_i]^{\tau_B}_i / y_j\}[c_j]^{\{\varepsilon\}\tau}_l) : \{\varepsilon\}\tau$.
\end{enumerate}
\end{proof}
\end{lemma}

\begin{lemma} (Progress) \\
If $\varnothing \vdash c_i : \{\varepsilon\} \tau$ then either
\begin{enumerate}
\item  $c_i \longrightarrow c_i'$ 
\item  $c_i = \m{return} v_i$
\item $c_i = op(v_i; y_i.c_i')$
\item $c_i = [op]^\varepsilon_l(v_i; y_i.c_i')$
 \end{enumerate}
\begin{proof}
The proof is a straightforward inductive argument on the structure of $c$.
\end{proof}

\end{lemma}







\begin{definition}
A i-computation $c$ is \underline{oblivious} to effect label $f$ if $f \not\in Dom(\delta_i)$, and for all subexpression $[e]^\tau_j$ and subcomputation $[c]^\sigma_j$, $f \not\in Dom(\delta_j)$
\end{definition}


\begin{theorem} 

Let $c_1$ and $c_2$ be computations that are oblivious to the effect $f$.  If $c_1 \approx c_2$, $c_1 \rightarrow c_1'$, $c_2 \rightarrow c_2'$, then $c_1' \approx c_2'$. Furthermore,  If $e_1, e_2$ oblivious to f, $e_1 \approx e_2$, $e_1 \rightarrow e_1'$, $e_2 \rightarrow e_2'$, then $e_1' \approx e_2'$

The relation $\approx$ is defined as follows:
\begin{figure}[H]
\flushleft
\footnotesize{

$\fbox{$e \approx e$}$
\[
\begin{array}{c}
\infer[\textsc{(R-Var)}]{x \approx x}
{} \qquad \infer[\textsc{(R-Unit)}]{() \approx ()}{} \\[3ex]
\infer[\textsc{(R-Lam)}]{\lambda x:\tau.\ c \approx \lambda x:\tau.\ c'}{c \approx c'} \qquad
\infer[\textsc{(R-EmbedExp)}]{[e]^\tau_l \approx [e']^\tau_l}{e \approx e'}
\end{array}
\]


$\fbox{$c \approx c$}$
\[
\begin{array}{c}
\infer[\textsc{(R-Ret)}]
  {\m{return} e \approx \m{return} e'}
  {e \approx e'}  
  \quad 
\infer[\textsc{(R-op)}]
  {op''(e; y.c) \approx op''(e'; y.c')}
  {e \approx e' & c \approx c'}
  \\[3ex]
\infer[\textsc{(R-Seq)}]
  {\m{do} x \leftarrow c \m{in} d \approx \m{do} x \leftarrow c' \m{in} d'}
  {c \approx c' & d  \approx d'} \quad
\infer[\textsc{(R-App)}]
  {e_1\ e_2 \approx e_1'\ e_2'}
  {e_1 \approx e_1' & e_2 \approx e_2'} \\[3ex]
\infer[\textsc{(R-Handle)}]
  {\m{with} h \m{handle} c \approx \m{with} h' \m{handle} c'}
  {h \approx h' & c \approx c'} \quad 
\infer[\textsc{(R-Embed)}]
  {[c_j]^\sigma_l \approx [c_j']^\sigma_l}
  {c_j \approx c_j'} \\[3ex]

\infer[\textsc{(R-Embedop1)}]
  {[op'']^\varepsilon_l(e; y.c) \approx [op'']^\varepsilon_l(e'; y.c')}
  {e \approx e' & c \approx c'}
  \quad
\infer[\textsc{(R-Embedop2)}]
  {[op]^\varepsilon_l(e; y.c) \approx [op']^\varepsilon_l(e'; y.c')}
  {e \approx e' & c \approx c' & \exists i \in l, \delta_i(f) = op, op'} \\[3ex]
\end{array}
\]

$\fbox{$h \approx h$}$
\[
\begin{array}{c}
\infer[\textsc{(R-Handler)}]{\begin{gathered} \{\m{return} x \mapsto c_r, op_1(x_1, k_1) \mapsto c_1, \dots, op_n(x_n, k_n) \mapsto c_n\} \approx \\\{\m{return} x \mapsto c_r', op_1(x_1, k_1) \mapsto c_1', \dots, op_n(x_n, k_n) \mapsto c_n'\}  
 \end{gathered} }{ c_r \approx c_r' & c_1 \approx c_1', \dots c_n \approx c_n'} 
\end{array}
\]


}
\caption{Definition of $\approx$}
\end{figure}




\begin{proof}(Sketch) By induction on derivation of $c_1 \approx c_2$ and $e_1 \approx e_2$
\begin{enumerate}
\item R-Ret:
  The only reduction rule that applies is E-Ret, so we have $e_1 \longrightarrow e_1'$ and $e_2 \longrightarrow e_2'$. By IH, we have $e_1' \approx e_2'$. Then the result follows by R-Ret
\item R-Op: The only reduction rule that applies is E-Op. The result is immediate by IH.
\item R-Seq: If the reduction rule is E-Seq1, then result is immediate by IH. 

If the reduction rule is E-Seq2. Then we have $c_1 = \m{do} x \leftarrow \m{return} v_1 \m{in} d_1$, $c_2 = \m{do} x \leftarrow \m{return} v_2 \m{in} d_2$. By inversion, we have $v_1 \approx v_2$ and $d_1 \approx d_2$. So we have $\{v_1/x\}d_1 \approx \{v_2/x\}d_2$.

If the reduction rule is E-Seq3, then $c_1 = \m{do} x \leftarrow op(v_1; y. k_1) \m{in} d_1$, $c_2= \m{do} x \leftarrow op(v_2; y. k_2) \m{in} d_2$. By inversion, we have $k_1 \approx k_2$ and $d_1 \approx d_2$. So $\m{do} x \leftarrow k_1 \m{in} d_1 \approx \m{do} x \leftarrow k_2 \m{in} d_2$. So $op(v_1; y. \m{do} x \leftarrow k_1 \m{in} d_1) \approx op(v_2; y. \m{do} x \leftarrow k_2 \m{in} d_2)$. The proof is similar for rule E-Seq4.

\item R-App: The cases for reduction rules E-App1 and E-App2 follows by IH. If reduction rule is E-App3. Then $c_1 = (\lambda x:\tau.\ d_1)\ v_1$ and $c_2 = (\lambda x:\tau.\ d_2)\ v_2$. By inversion we have $d_1 \approx d_2$ and $v_1 \approx v_2$. So we have $\{v_1/x\}d_1 \approx \{v_2/x\}d_2$.

\item R-Handle: If reduction rule is E-Handle1, then result follows by IH. 

If the reduction rule is E-Handle2. Then $c_1 = \m{with} h_1 \m{handle} \m{return} v_1$ and $c_2 = \m{with} h_2 \m{handle} \m{return} v_2$. By inversion we have $h_1 \approx h_2$, $v_1 \approx v_2$.  Let $\m{return} c_{r1} \in h_1$ and $\m{return} c_{r2} \in h_2$. By inversion we have $c_{r1} \approx c_{r2}$. So $\{v_1/x\}c_{r1} \approx \{v_2/x\}c_{r2}$.

If the reduction rule is E-Handle3. Then $c_1 = \m{with} h_1 \m{handle} op(v_1; y. k_1)$ and $c_2 = \m{with} h_2 \m{handle} op(v_2; y.k_2) $. By inversion we have $v_1 \approx v_2$, $k_1 \approx k_2$ and $h_1 \approx h_2$. Then by equivalents rules we derive $c_1' \approx c_2'$. The case for E-Handle4 is similar.

\item R-Embed: If reduction is E-Embed1,  result is immediate by IH. If reduction rule is E-Embed2, then $c_1 = [\m{return} v_1]^{\{\varepsilon\}\tau}_l$ and $c_2 = [\m{return} v_2]^{\{\varepsilon\}\tau}_l$. It is easy to see $[v_1]^\tau \approx [v_2]^\tau$. So the result holds.

If the reduction rule is E-Embed3, Then $c_1 = [op(v_1; y. k_1)]{\{\varepsilon\}\tau}_l$ and $c_2 = [op(v_2; y. k_2)]^{\{\varepsilon\}\tau}_l$. By inversion we have $v_1 \approx v_1$, $k_1 \approx k_2$. Then by equivalent rules we have $c_1' \approx c_2'$. Same arguments apply for E-Embed4.

\item R-EmbedOp1: If reduction rule is E-EmbedOp1, then result follows by IH. If reduction rules is E-EmbedOp2 or E-EmbedOp3, reduction does not affect terms except effect annotation, so the equivalence relation still hods after reduction.

\item R-EmbedOp2: Reduction rules E-EmbedOp1 and E-EmbedOp2 are similar to the previous case. If the reduction rule is E-EmbedOp3, then by R-EmbedOp2, the operations $op$ and $op'$ are exported as effect $f$ by some agent, and since current agent is oblivious to $f$, this case is impossible.

\end{enumerate}


\end{proof}


\end{theorem}

\pagebreak
\section{Translation of the Abstraction Problem}
In this section we show an example of the process of evaluation of the example program presented in \ref{sec-motivation}. The original example could be rewritten  as follows:
\begin{lstlisting}[mathescape = true]
op : 1 -> 1
  
module b: B
  effect f = op
  def m() : {f} Unit
    op ()
  def handler(c: 1 -> {f} 1) : {} Int = 
    handle c () with
    | op () -> 1
    | return _ -> 0
\end{lstlisting}

The operation \li{op} is defined globally, and the module \li{b} defines effect \li{f} to be equivalent to \li{op},  an effectful method \li{m}, and an handler method \li{method}. The example program that we will evaluate is written as follows. The handler method from module \li{b} is invoked, and the argument is a computation that calls the method \li{b.m}, which is surrounded by a handler that handles \li{op}. 
\begin{lstlisting}[mathescape = true]
b.handler(
  () => handle b.m() with
          | op -> resume ()
          | return _ -> ()
 )
 \end{lstlisting}
 Then we rewrite the example program in our agent-based calculus: Since the code is a client of \li{b}, any method call from the module \li{b} should be surrounded by an embedding.  So the handler functions is wrapped in an embedding with type annotation \li{(1 -> \{f\} -> 1) -> Int}, and the handled function in the argument is also embedded with an annotation \li{1 -> \{f\} 1}. In the following evaluation process we assume that there is an agent \li{b} that represents the module \li{b}, and an agent \li{a} that represents the client code that invokes functions from module \li{b}

\begin{lstlisting}[mathescape = true]
// Translation of Example Program
[$\lambda$c: 1 -> {f} 1. 
  handle c() with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{(1 \rightarrow \{f\} 1) \rightarrow \{\} int}_b$
($\lambda$_:1. 
  handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
  | op(x, k) -> k ()
  | return _ -> return ())
 \end{lstlisting}
 
 Then according to the dynamic rules, we evaluate the handler function to a value that is not embedded. The program is therefore evaluated to 
 \begin{lstlisting}[mathescape = true]
 ($\lambda$c: 1 -> {f} 1. 
  [handle [c]$^{1 \rightarrow \{f\} 1}_a$  () with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$)
($\lambda$_:1. 
  handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
  | op(x, k) -> k ()
  | return _ -> return ())
  \end{lstlisting}
 
Since the function is evaluated to a value, we can perform a $\beta$-reduction:
 \begin{lstlisting}[mathescape = true]
  [handle 
     [$\lambda$_:1. 
      handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{1 \rightarrow \{f\} 1}_a$  () 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
 \end{lstlisting}
 
 Now we need to evaluate the outter-most handle computation in the embedding. The first step is to evaluate the handled computation, which is a function application. We first evaluate the function
  \begin{lstlisting}[mathescape = true]
[handle 
     $\lambda$_:1. 
      [handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{\{f\} 1}_a$  () 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
 \end{lstlisting}
 Then we pass in the argument, which is a unit value
  \begin{lstlisting}[mathescape = true]
[handle 
      [handle [$\lambda$_:1. op()]$^{1 \rightarrow \{f\} 1}_b$ () with
      | op(x, k) -> k ()
      | return _ -> return () ]$^{\{f\} 1}_a$ 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
\end{lstlisting}  
Then we evaluate the inner handling computation. Since the inner handling computation is evaluated as a client code and the operation \li{op} in an embedding from module \li{b}, the operation will not be handled by the current handler. Instead, it would be lifted out of the handler.

%  \begin{lstlisting}[mathescape = true]
%[handle 
%      [handle $\lambda$_:1. [op()]$^{\{f\} 1}_b$ () with
%      | op(x, k) -> k ()
%      | return _ -> return () ]$^{\{f\} 1}_a$ 
%  with 
 % | op(x, k) -> return 1
  %| return x -> return 0)]$^{ \{\} int}_b$
  
%\\steps--->
%[handle 
 %     [handle [op()]$^{\{f\} 1}_b$ with
  %    | op(x, k) -> k ()
  %    | return _ -> return () ]$^{\{f\} 1}_a$ 
 % with 
 % | op(x, k) -> return 1
  %| return x -> return 0)]$^{ \{\} int}_b$
  
%\\steps--->
%[handle 
%     [handle op$^f_b$((), y.return y) with
 %     | op(x, k) -> k ()
 %     | return _ -> return () ]$^{\{f\} 1}_a$ 
 % with 
 % | op(x, k) -> return 1
 % | return x -> return 0)]$^{ \{\} int}_b$
 % \end{lstlisting}

  \begin{lstlisting}[mathescape = true]
[handle 
      [op$^f_b$((), y. handle return y with
                       | op(x, k) -> k ()
                       | return _ -> return () 
          )]$^{\{f\} 1}_a$ 
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$
  \end{lstlisting}
  
At this point since the operation \li{op} is lifted to the agent b, where the effect $f$ is transparent, the handler would be able to handle it. The result of this computation is \li{return 1}, because the continuation is discarded by the handler.
  \begin{lstlisting}[mathescape = true]
  [handle 
      op$^f_{ba}$((), y. [handle return y with
                       | op(x, k) -> k ()
                       | return _ -> return ()]$^{\{f\} 1}_a$ 
          )
  with 
  | op(x, k) -> return 1
  | return x -> return 0)]$^{ \{\} int}_b$   
\end{lstlisting}

